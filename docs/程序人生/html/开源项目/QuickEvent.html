<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QuickEvent - 程序人生</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">程序人生</a></li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 读后感</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../读后感/C++沉思录.html"><strong aria-hidden="true">1.1.</strong> C++沉思录</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 开源项目</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../开源项目/KISSDicomViewer.html"><strong aria-hidden="true">2.1.</strong> KISSDicomViewer</a></li><li class="chapter-item expanded "><a href="../开源项目/OpenBrowser.html"><strong aria-hidden="true">2.2.</strong> OpenBrowser</a></li><li class="chapter-item expanded "><a href="../开源项目/QuickEvent.html" class="active"><strong aria-hidden="true">2.3.</strong> QuickEvent</a></li><li class="chapter-item expanded "><a href="../开源项目/GithubImageHost.html"><strong aria-hidden="true">2.4.</strong> GithubImageHost</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 回溯反思</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../回溯反思/离职随笔(2019).html"><strong aria-hidden="true">3.1.</strong> 离职随笔(2019)</a></li><li class="chapter-item expanded "><a href="../回溯反思/回顾2019.html"><strong aria-hidden="true">3.2.</strong> 回顾2019</a></li><li class="chapter-item expanded "><a href="../回溯反思/2021伊始_由一次找虐的面试引发的反思.html"><strong aria-hidden="true">3.3.</strong> 由一次找虐的面试引发的反思(2021)</a></li><li class="chapter-item expanded "><a href="../回溯反思/离职随笔(2021).html"><strong aria-hidden="true">3.4.</strong> 离职随笔(2021)</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../../../index.html">更多</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">程序人生</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
    <img src="https://img-blog.csdnimg.cn/20200723202619960.png" alt="Logo"/>
</p>
<p align="center">
  <img src="https://img.shields.io/badge/build-passing-brightgreen.svg">
  <img src="https://img.shields.io/badge/platform-Windows%20%7C%20Linux%20%7C%20macOS%20%7C%20iOS%20%7C%20Android%20%7C%20MCU-brightgreen.svg">
  <img src="https://img.shields.io/badge/architecture-Qt%20%7C%20Gooogle%20c++-blue.svg">
  <img src="https://img.shields.io/badge/license-BSD%202%20Clause-blue.svg">
</p>
<h1 id="1-什么是-quickevent"><a class="header" href="#1-什么是-quickevent">1 什么是 QuickEvent?</a></h1>
<ul>
<li>✂️ 仅600行C++代码</li>
<li>🔣 支持多语言,采用 UTF-8 编码</li>
<li>⚡ 使用<strong>QuickEvent</strong>设计复杂功能可以让开发者，更加专注与自己模块或功能点的开发</li>
<li>💉 利用<strong>QT</strong>的元对象属性，实现控制类的自动实例化</li>
<li>🔨 高内聚，低耦合，不仅让协同开发变得简单，也让重构变的非常轻松；</li>
<li>🐋 生产级别代码clone即用，提供参考Demo</li>
<li>⚙️️ 跨平台
| platform | Support | 
| --- | --- | 
| Windos VS-2017 | √ | 
| Linux Gcc6 | √ | 
| Mac Gcc6 | √ | </li>
</ul>
<h1 id="2-为何使用-quickevent"><a class="header" href="#2-为何使用-quickevent">2 为何使用 QuickEvent?</a></h1>
<p>| 1 | 界面与控制逻辑完全分离 | 
| --- | --- | 
| <strong>2</strong> | <strong>事件管理</strong> | 
| <strong>3</strong> | <strong>线程管理</strong> | 
| <strong>4</strong> | <strong>控制类装填</strong> | </p>
<h1 id="3-如何使用-quickevent"><a class="header" href="#3-如何使用-quickevent">3 如何使用 QuickEvent?</a></h1>
<ul>
<li>QuickEvent使用: 在你的<strong>Cmake</strong>工程中添加<strong>QuickEvent</strong>库</li>
<li>QuickEvent开发: 您可以获得源码，并在任何平台（Windows/Linux/Mac）上开发它</li>
</ul>
<h2 id="1-quickevent开发"><a class="header" href="#1-quickevent开发">1. QuickEvent开发</a></h2>
<ol>
<li>Fork 本仓库</li>
<li>新建 Feat_xxx 分支</li>
<li>提交代码</li>
<li>新建 Pull Request</li>
</ol>
<h2 id="2--quickevent使用"><a class="header" href="#2--quickevent使用">2.  QuickEvent使用</a></h2>
<h2 id="3-31-发布和订阅"><a class="header" href="#3-31-发布和订阅">3. 3.1 发布和订阅</a></h2>
<h4 id="311-311关联quickevent"><a class="header" href="#311-311关联quickevent">3.1.1. 3.1.1.关联QuickEvent</a></h4>
<p>引入<strong>QUICK_EVENT</strong>宏让你的自己定义的类具有<strong>发布和订阅</strong>事件的能力；<br />
<strong>QuickWork、QuickScript</strong>默认已经引入QUICK_EVENT。</p>
<pre><code class="language-cpp">// 使用QUICK_EVENT宏
class Dialog : public QDialog {
    Q_OBJECT
    QUICK_EVENT(QDialog)
  public:
    explicit Dialog(QWidget *parent = nullptr);
    ...
};

// 继承自QuickWork
class UserWork : public QuickWork {
    Q_OBJECT
  public:
    Q_INVOKABLE explicit UserWork(QObject *parent = nullptr);
    ...
};
</code></pre>
<ul>
<li>注:<strong>QObject</strong>及其子类才能通过<strong>QUICK_EVENT</strong>宏引入发布订阅；</li>
</ul>
<h4 id="312-312订阅消息"><a class="header" href="#312-312订阅消息">3.1.2. 3.1.2.订阅消息</a></h4>
<p><strong>QuickApplication</strong>提供了<strong>subscibeEvent</strong>方法用来订阅一个消息。 
<strong>QUICK_SUBSCIBE</strong>宏可以实现便捷订阅。 </p>
<pre><code class="language-cpp">// 订阅show_time消息
Dialog::Dialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::Dialog) {
    ui-&gt;setupUi(this);
    QuickApplication::subscibeEvent(this, &quot;show_time&quot;);
    ...
}

// QUICK_SUBSCIBE便捷订阅事件
SessionManager::SessionManager(QuickWork *parent) :
    QuickWork(parent) {
    QUICK_SUBSCIBE(&quot;Manager_LoginType&quot;)
    QUICK_SUBSCIBE(&quot;Widget_SessionType&quot;)
    this-&gt;Initial();
}
</code></pre>
<p><strong>QUICK_SUBSCIBE</strong>定义：</p>
<pre><code class="language-cpp">#define QUICK_SUBSCIBE_OBJ(obj,name)\
    QuickApplication::subscibeEvent(obj, name);
#define QUICK_SUBSCIBE(name)\
    QuickApplication::subscibeEvent(this, name);
#define QUICK_SUBSCIBE_H(name,lev)\
    QuickApplication::subscibeEvent(this, name,lev);
#define QUICK_SUBSCIBE_L(name,lev)\
    QuickApplication::subscibeEvent(this, name,100+lev);
</code></pre>
<h4 id="313-313发布消息"><a class="header" href="#313-313发布消息">3.1.3. 3.1.3.发布消息</a></h4>
<p><strong>QuickApplication</strong>提供了<strong>publishEvent</strong>方法用来发布一个消息。
<strong>QUICK_PUBLISH1</strong>宏可以实现便捷发布事件。</p>
<pre><code class="language-cpp">// 发布show_time消息
TestWork::TestWork(QObject *parent) : QuickWork(parent) {
    QTimer::singleShot(2000, this, []() {
        auto time = QDateTime::currentDateTime();
        QuickApplication::publishEvent(&quot;show_time&quot;, Qt::AutoConnection, time);
    });
}

// QUICK_PUBLISH便捷发布消息
void RightControlManager::Slot_WidgetRightControlType(const qint32 &amp;type) {
    switch (type) {
        case RightControlWidget::Remodel: {
                QUICK_PUBLISH1(&quot;Manager_RightControlType&quot;, qint32(RightControlWidget::Remodel))
                break;
            }
        default:
            break;
    }
}
</code></pre>
<p><strong>publishEvent</strong>定义：</p>
<pre><code class="language-cpp">template&lt;class ...Args&gt;
static void publishEvent(QByteArray eventName, Qt::ConnectionType type, Args &amp;&amp;... args) {
    ...
}
</code></pre>
<p><strong>QUICK_PUBLISH</strong>定义：</p>
<ul>
<li>自动模式发布 <strong>QUICK_PUBLISHX</strong>，X表示发布参数数量</li>
<li>同步触发模式发布 <strong>QUICK_Direct_PUBLISHX</strong>，X表示发布参数数量</li>
<li>异步触发模式发布 <strong>QUICK_Queued_PUBLISHX</strong>，X表示发布参数数量</li>
<li>异步等待模式发布 <strong>QUICK_BlockingQueued_PUBLISHX</strong>，X表示发布参数数量</li>
</ul>
<pre><code class="language-cpp">#define QUICK_PUBLISH1(name,arg1)\
    QuickApplication::publishEvent(name,Qt::AutoConnection, arg1);
#define QUICK_PUBLISH2(name,arg1,arg2)\
    QuickApplication::publishEvent(name,Qt::AutoConnection, arg1,arg2);
#define QUICK_PUBLISH3(name,arg1,arg2,arg3)\
    QuickApplication::publishEvent(name,Qt::AutoConnection, arg1,arg2,arg3);
#define QUICK_PUBLISH4(name,arg1,arg2,arg3,arg4)\
    QuickApplication::publishEvent(name,Qt::AutoConnection, arg1,arg2,arg3,arg4);

#define QUICK_Direct_PUBLISH1(name,arg1)\
    QuickApplication::publishEvent(name,Qt::DirectConnection, arg1);
#define QUICK_Direct_PUBLISH2(name,arg1,arg2)\
    QuickApplication::publishEvent(name,Qt::DirectConnection, arg1,arg2);
#define QUICK_Direct_PUBLISH3(name,arg1,arg2,arg3)\
    QuickApplication::publishEvent(name,Qt::DirectConnection, arg1,arg2,arg3);

#define QUICK_Queued_PUBLISH1(name,arg1)\
    QuickApplication::publishEvent(name,Qt::QueuedConnection, arg1);
#define QUICK_Queued_PUBLISH2(name,arg1,arg2)\
    QuickApplication::publishEvent(name,Qt::QueuedConnection, arg1,arg2);
#define QUICK_Queued_PUBLISH3(name,arg1,arg2,arg3)\
    QuickApplication::publishEvent(name,Qt::QueuedConnection, arg1,arg2,arg3);

#define QUICK_BlockingQueued_PUBLISH1(name,arg1)\
    QuickApplication::publishEvent(name,Qt::BlockingQueuedConnection, arg1);
#define QUICK_BlockingQueued_PUBLISH2(name,arg1,arg2)\
    QuickApplication::publishEvent(name,Qt::BlockingQueuedConnection, arg1,arg2);
#define QUICK_BlockingQueued_PUBLISH3(name,arg1,arg2,arg3)\
    QuickApplication::publishEvent(name,Qt::BlockingQueuedConnection, arg1,arg2,arg3);
</code></pre>
<ul>
<li>注:使用Qt::AutoConnection，发布消息时，跨线程处于采用异步触发。</li>
</ul>
<h4 id="314-314接受并处理消息"><a class="header" href="#314-314接受并处理消息">3.1.4. 3.1.4.接受并处理消息</a></h4>
<p>引入发布和订阅功能的类通过实现event_ + 消息名称的槽函数即可接受并处理publishEvent推送消息</p>
<pre><code class="language-cpp">private slots:
    void event_show_time(const QDateTime &amp;time);
...
void Dialog::event_show_time(const QDateTime &amp;time) {
    box-&gt;setText(time.toString());
    box-&gt;show();
}
</code></pre>
<ul>
<li>注:需要函数参数列表匹配一致</li>
</ul>
<h4 id="315-315取消订阅"><a class="header" href="#315-315取消订阅">3.1.5. 3.1.5.取消订阅</a></h4>
<p><strong>QuickApplication</strong>提供了<strong>UnsubscribeEvent</strong>方法用来取消订阅消息。
<strong>QUICK_DESTRUCT</strong>宏可以实现便捷取消订阅。</p>
<p><strong>UnsubscribeEvent</strong>定义：</p>
<pre><code class="language-cpp">bool QuickApplication::UnsubscribeEvent(QObject *listener, QByteArray eventName) {
    QWriteLocker loker(&amp;s_lock);
    bool result = false;
    if(s_quick_event_pool.contains(eventName)) {
        QMap&lt;qint32, QObject *&gt; tmplist = s_quick_event_pool[eventName];
        tmplist.remove(tmplist.key(listener));
        s_quick_event_pool.insert(eventName, tmplist);
        result = true;
    }
    if(s_quick_event_pool_high.contains(eventName)) {
        QMap&lt;qint32, QObject *&gt; tmplist = s_quick_event_pool[eventName];
        tmplist.remove(tmplist.key(listener));
        s_quick_event_pool.insert(eventName, tmplist);
        result = true;
    }
    if(s_quick_event_pool_low.contains(eventName)) {
        QMap&lt;qint32, QObject *&gt; tmplist = s_quick_event_pool[eventName];
        tmplist.remove(tmplist.key(listener));
        s_quick_event_pool.insert(eventName, tmplist);
        result = true;
    }
    return result;
}

bool QuickApplication::UnsubscribeEvent(QObject *listener) {
    QWriteLocker loker(&amp;s_lock);
    foreach (auto var, s_quick_event_pool.keys()) {
        s_quick_event_pool[var].remove(s_quick_event_pool[var].key(listener));
    }
    foreach (auto var, s_quick_event_pool_low.keys()) {
        s_quick_event_pool[var].remove(s_quick_event_pool[var].key(listener));
    }
    foreach (auto var, s_quick_event_pool_high.keys()) {
        s_quick_event_pool[var].remove(s_quick_event_pool[var].key(listener));
    }
    return true;
}
</code></pre>
<p><strong>QUICK_DESTRUCT</strong>定义：</p>
<pre><code class="language-cpp">#define QUICK_DESTRUCT \
    QuickApplication::UnsubscribeEvent(this);\
</code></pre>
<h4 id="316-316订阅优先级"><a class="header" href="#316-316订阅优先级">3.1.6. 3.1.6.订阅优先级</a></h4>
<p>默认情况下跟Qt的信号槽一样，根据订阅顺序依次接受并处理消息。<strong>QuickEvent</strong>把订阅者分为三类，高级别、默认、低级别。当发布消息后，所有订阅者按照高级订阅、默认订阅、低级订阅的顺序依次执行。其中高级订阅和低级订阅分别有自己的顺序，默认订阅则无序。</p>
<pre><code class="language-cpp">  static QMap &lt; QByteArray, QMap&lt;qint32, QObject *&gt; &gt; s_quick_event_pool_high;
  static QMap &lt; QByteArray, QMap&lt;qint32, QObject *&gt; &gt; s_quick_event_pool;
  static QMap &lt; QByteArray, QMap&lt;qint32, QObject *&gt; &gt; s_quick_event_pool_low;
</code></pre>
<h4 id="317-317发布订阅类型"><a class="header" href="#317-317发布订阅类型">3.1.7. 3.1.7.发布订阅类型</a></h4>
<p><strong>QuickEvent</strong>发布订阅支持四种模式。<br />
请注意，使用<strong>QuickEvent</strong>时往往不清楚对方详细代码，使用阻塞发布请务必小心，防止死锁！</p>
<pre><code class="language-cpp">  ConnectionType::AutoConnection,
  // 自动模式发布,
  // 订阅者者和发布者在同一个线程使用同步调用。
  // 订阅者和发布者不在一个线程采用异步调用。
  // 调用时按照顺序执行 QuickApplication::methodIndex调用
  ConnectionType::DirectConnection,  同步触发模式发布
  // 把本线程所有订阅者打包到一个列队依次顺序执行
  ConnectionType::QueuedConnection,  异步触发模式发布
  // 把每个线程单独打包成列队，每个线程内依次执行   QApplication::postEvent
  ConnectionType::BlockingQueuedConnection,  异步等待模式发布
  // 把所有线程所有订阅者按照订阅顺序打包，依次调用
  // QuickApplication::methodIndex调用
</code></pre>
<h2 id="4-32-控制类装填"><a class="header" href="#4-32-控制类装填">4. 3.2 控制类装填</a></h2>
<p>Quick Event代码模型提供两个控制类： <strong>QuickWork、QuickScript</strong></p>
<h4 id="411-321-quickscript及其子类"><a class="header" href="#411-321-quickscript及其子类">4.1.1. 3.2.1 QuickScript及其子类：</a></h4>
<p>继承自QThread的脚本基类，使用方式 </p>
<p><strong>初始化：</strong></p>
<ol>
<li>实例化</li>
<li>指定渲染窗口ui（如果有）</li>
<li>绑定QThread::finished()</li>
</ol>
<p><strong>执行执行：</strong></p>
<ol>
<li>开启渲染窗口交互</li>
<li>交互完成传入脚本计算数据、参数</li>
<li>执行计算脚本</li>
<li>开启渲染窗口交互</li>
<li>关闭渲染窗口交互</li>
</ol>
<p><strong>结束：</strong></p>
<ol>
<li>deleteLater();</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>整个类仅Execute()位于新线程内，其余（渲染窗口交互）所有均位于父线程。</li>
<li>提供 Wait、Wake接口，可以在计算脚本中穿插交互</li>
<li>提供SignalProgressIn信号用来打印脚本计算进度</li>
</ol>
<h4 id="412-322-quickwork及其子类"><a class="header" href="#412-322-quickwork及其子类">4.1.2. 3.2.2 QuickWork及其子类：</a></h4>
<p>允许被反射，通过<strong>QUICK_AUT</strong>宏和<strong>QuickController</strong>，可以实现控制类的自动实例化。
<strong>QuickController</strong>类用来实现反射，其内部统一自动实例化<strong>QuickWork</strong>及其子类。<strong>QuickWork</strong>的线程归属可以通过 <strong>move_type</strong>来决定被反射后移动大到线程的位置。</p>
<pre><code class="language-cpp">MainThread = 0, //反射在主线程中且不移动，start函数不能为死循环否者QT事件循环也将被卡死；
WorkThread,     //反射在工作线程中，区别与主线程；
NewThread       //反射在新的线程中，会被每个反射出对象创建一个新的线程；
</code></pre>
<p><strong>QUICK_AUTO</strong>宏作用</p>
<ol>
<li>向QT元对象系统注册自己类型</li>
<li>在mian方法之前将自己类名注册到需要反射类列表中，QuickController对象创建后会反射出所有已注册的类，并做线程归属处理</li>
</ol>
<p><strong>QUICK_AUTO</strong>定义：</p>
<pre><code class="language-cpp">#define QUICK_AUTO(ClassName)\
    Q_DECLARE_METATYPE(ClassName *) \
    static int ClassId##ClassName = qRegisterMetaType&lt;ClassName *&gt;();\
    static void *ThisPtr##ClassName = QuickController::NewInstance(#ClassName);

#define QUICK_AUTO_H(ClassName,value)\
    Q_DECLARE_METATYPE(ClassName *) \
    static int ClassId##ClassName = qRegisterMetaType&lt;ClassName *&gt;();\
    static void *ThisPtr##ClassName = QuickController::NewInstance(\
                                      #ClassName,QuickController::High,value);

#define QUICK_AUTO_L(ClassName,value)\
    Q_DECLARE_METATYPE(ClassName *) \
    static int ClassId##ClassName = qRegisterMetaType&lt;ClassName *&gt;();\
    static void *ThisPtr##ClassName = QuickController::NewInstance(\
                                      #ClassName,QuickController::Low,value);

</code></pre>
<p><strong>QuickController</strong>反射<strong>QuickWork</strong>及其子类顺序类似订阅顺序，分为三个级别。高优先级、默认、低优先级。先反射高优先级类、默认优先级类、低优先级类。其中默认优先级里的类无序，高优先级、低优先级里类有序。</p>
<blockquote>
<p>原理：C/C++无法在main之前执行复杂的操作，通过在.h文件中定义static变量且通过函数方式赋值，可以main之前执行一段代码，利用static在类外修饰变量表示该变量仅对于文件内部可见的原理，不会产生编译错误；[当然对C++11支持良好编译器可以使用constexpr]但是这个操作可能被执行多次，所以反射类列表使用了Set容器防止重复插入；</p>
</blockquote>
<ul>
<li>注:1. 继承自<strong>QuickWork</strong>后可以覆盖<strong>QuickWork::start</strong>函数，<strong>start</strong>函数一定会在被移动到的线程中调用；</li>
<li>注:2. 高优先级、低优先级如果插入重复顺序会打印重复信息，让后只反射其中一个；</li>
</ul>
<pre><code class="language-cpp">----------------- QuickController OrderLow cover:----------------- 
cover key: 25 
cover name: &quot;TestWork&quot; &quot;UserWork&quot; 
----------------------------------
</code></pre>
<h2 id="33-quickevent-初始化"><a class="header" href="#33-quickevent-初始化">3.3 QuickEvent 初始化</a></h2>
<p>只使用<strong>QuickEvent</strong>的发布订阅功能无需初始化。<strong>QuickEvent</strong>的控制类反射与生存周期管理<strong>QuickController</strong>需要在main函数中初始化。
<strong>QUICK_INSTALL()</strong> 宏和 <strong>QUICK_INSTALL_DETAILED()</strong> 宏均可实现初始化，<strong>QUICK_INSTALL_DETAILED()</strong> 增加了打印 <strong>QuickEvent</strong> 更详细的相关信息，比如版本信息、详细发布订阅列队等，方便调试使用。</p>
<pre><code class="language-cpp">#include &quot;dialog.h&quot;
#include &lt;QuickEvent&gt;
#include &lt;QFile&gt;
int main(int argc, char **argv) {
    QApplication a(argc, argv);
    QUICK_INSTALL()// QUICK_INSTALL  QUICK_INSTALL_DETAILED
    QUICK_SETSTYLE(&quot;../../Examples/resource/Style/gray_style.qss&quot;)
    Dialog dialog;
    dialog.show();
    return a.exec();
}
</code></pre>
<h2 id="5-34-quickevent-所有宏介绍"><a class="header" href="#5-34-quickevent-所有宏介绍">5. 3.4 QuickEvent 所有宏介绍</a></h2>
<table><thead><tr><th><strong>QuickEvent</strong>宏</th><th>说明</th></tr></thead><tbody>
<tr><td><strong>QUICK_AUTO(ClassName)</strong></td><td>向QT元对象系统注册自己类型、实例化本身（默认优先级）</td></tr>
<tr><td><strong>QUICK_AUTO_H(ClassName,value)</strong></td><td>向QT元对象系统注册自己类型、实例化本身（高优先级）</td></tr>
<tr><td><strong>QUICK_AUTO_L(ClassName,value)</strong></td><td>向QT元对象系统注册自己类型、实例化本身（低优先级）</td></tr>
<tr><td><strong>QUICK_EVENT(PARENTANME)</strong></td><td>使类本身支持发布订阅功能</td></tr>
<tr><td>-</td><td>-</td></tr>
<tr><td><strong>QUICK_DESTRUCT</strong></td><td>取消自身的所有订阅</td></tr>
<tr><td>-</td><td>-</td></tr>
<tr><td><strong>QUICK_SUBSCIBE_OBJ(obj,name)</strong></td><td>便捷订阅，订阅者、订阅名称（订阅者可以是自己内部变量）</td></tr>
<tr><td><strong>QUICK_SUBSCIBE(name)</strong></td><td>向自身便捷订阅</td></tr>
<tr><td><strong>QUICK_SUBSCIBE_H(name,lev)</strong></td><td>向自身便捷高级订阅，lev表示高级订阅中的排序，重复则顶掉之前</td></tr>
<tr><td><strong>QUICK_SUBSCIBE_L(name,lev)</strong></td><td>向自身便捷低级订阅，lev表示低级订阅中的排序，重复则顶掉之前</td></tr>
<tr><td>-</td><td>-</td></tr>
<tr><td><strong>QUICK_PUBLISH1(name,arg1)</strong></td><td>默认模式发布，1个参数</td></tr>
<tr><td><strong>QUICK_PUBLISH2(name,arg1,arg2)</strong></td><td>默认模式发布，2个参数</td></tr>
<tr><td><strong>QUICK_PUBLISH3(name,arg1,arg2,arg3)</strong></td><td>默认模式发布，3个参数</td></tr>
<tr><td><strong>QUICK_PUBLISH4(name,arg1,arg2,arg3,arg4)</strong></td><td>默认模式发布，4个参数</td></tr>
<tr><td><strong>QUICK_Direct_PUBLISH1(name,arg1)</strong></td><td>同步模式发布，1个参数</td></tr>
<tr><td><strong>QUICK_Direct_PUBLISH2(name,arg1,arg2)</strong></td><td>同步模式发布，2个参数</td></tr>
<tr><td><strong>QUICK_Direct_PUBLISH3(name,arg1,arg2,arg3)</strong></td><td>同步模式发布，3个参数</td></tr>
<tr><td><strong>QUICK_Queued_PUBLISH1(name,arg1)</strong></td><td>异步模式发布，1个参数</td></tr>
<tr><td><strong>QUICK_Queued_PUBLISH2(name,arg1,arg2)</strong></td><td>异步模式发布，2个参数</td></tr>
<tr><td><strong>QUICK_Queued_PUBLISH3(name,arg1,arg2,arg3)</strong></td><td>异步模式发布，3个参数</td></tr>
<tr><td><strong>QUICK_BlockingQueued_PUBLISH1(name,arg1)</strong></td><td>异步等待模式发布，1个参数</td></tr>
<tr><td><strong>QUICK_BlockingQueued_PUBLISH2(name,arg1,arg2)</strong></td><td>异步等待模式发布，2个参数</td></tr>
<tr><td><strong>QUICK_BlockingQueued_PUBLISH3(name,arg1,arg2,arg3)</strong></td><td>异步等待模式发布，3个参数</td></tr>
<tr><td>-</td><td>-</td></tr>
<tr><td><strong>QUICK_GETSET(name,type)</strong></td><td>变量快速读写接口</td></tr>
<tr><td><strong>QUICK_INITIAL_VAR(name,type)</strong></td><td>变量快速定义、读写接口</td></tr>
<tr><td><strong>QUICK_GETSET_Object(name,type)</strong></td><td>指针快速读写接口</td></tr>
<tr><td>-</td><td>-</td></tr>
<tr><td><strong>QUICK_INSTALL()</strong></td><td>QuickController初始化</td></tr>
<tr><td><strong>QUICK_INSTALL_DETAILED()</strong></td><td>QuickController初始化，打印详细信息</td></tr>
<tr><td><strong>QUICK_SETSTYLE(name)</strong></td><td>样式表初始化</td></tr>
</tbody></table>
<h1 id="4-版本更新说明"><a class="header" href="#4-版本更新说明">4 版本更新说明</a></h1>
<h3 id="11-更新200版本"><a class="header" href="#11-更新200版本">1.1. 更新2.0.0版本</a></h3>
<ol>
<li>通过引入变参模板使得事件响应函数(event_ + 消息名称)的定义更加自由;</li>
<li>发布订阅支持了:<br />
同步触发[DirectConnection]；<br />
异步触发[QueuedConnection]；<br />
异步触发等待[BlockingQueuedConnection]；</li>
</ol>
<h5 id="1111-存在问题"><a class="header" href="#1111-存在问题">1.1.1.1. 存在问题：</a></h5>
<ul>
<li>1.事件发布后如何确定调用触发函数匹配仍然不够完美;</li>
</ul>
<p>问题在于QT元对象系统对于方法参数类型的摘要(QMetaMethod::parameterTypes)和C++的typeid()差距过大。目前只匹配外部类型，对于模板无法处理，所以不建议重载参数个数相同的事件响应函数。比如：</p>
<pre><code class="language-cpp">void event_show_time(const QDateTime &amp;time, QList&lt;int&gt; list);
void event_show_time(const QDateTime &amp;time, QList&lt;QString&gt; list);
</code></pre>
<h5 id="1112-注意"><a class="header" href="#1112-注意">1.1.1.2. 注意</a></h5>
<ol>
<li>跨线程的事件发布传递参数需要使用QT已知的类型</li>
<li>同使用QT的<strong>QMetaObject::QMetaCallEvent</strong>一样<strong>QuickEvent</strong>在处理跨线程异步触发时也会在堆中创建变量的副本；</li>
<li>消息订阅者可能是多个，使用<strong>QSharedPointer::QVariant</strong>共享这块内存；所以传入参数会被转换成<strong>QVariant</strong>类型。</li>
<li>未知类型在编译时就会报错;</li>
<li>对于同步触发和异步触发等待，则支持任意类型参数；</li>
</ol>
<hr />
<h3 id="12-更新202版本"><a class="header" href="#12-更新202版本">1.2. 更新2.0.2版本</a></h3>
<ol>
<li>QuickEvent使用cmake来组织工程了，添加编译动态库版本，参考CMakeLists.txt；</li>
</ol>
<pre><code class="language-cpp">#true编译生成动态库; false编译生成静态库；
set(quickevent_BUILD_SHARED_LIBS false)
#ON编译示例 OFF不编译示例
set(quickevent_BUILD_EXAMPLES ON)
</code></pre>
<ol start="2">
<li>解决继承动自导出类后反射崩溃问题，以下摘自QT源码:qmetatype.h；</li>
</ol>
<pre><code class="language-cpp"> static int qt_metatype_id()
    {
        static QBasicAtomicInt metatype_id = Q_BASIC_ATOMIC_INITIALIZER(0);
        if (const int id = metatype_id.loadAcquire())
            return id;
		//继承自dll导出类的对象T模板类型无法识别，需要Q_DECLARE_METATYPE前置声明
        const char * const cName = T::staticMetaObject.className();
		...
    }
</code></pre>
<hr />
<h3 id="13-更新300版本"><a class="header" href="#13-更新300版本">1.3. 更新3.0.0版本</a></h3>
<ol>
<li>文件结构重新整理，便于快速整合到现有工程；</li>
<li>增加若干宏，使调用<strong>QuickEvnet</strong>发布订阅时代码更加整洁；</li>
<li>取消QuickApplication构造析构函数，剔除对原有Qt框架的侵入性</li>
<li>增加QuickEventConfig.h.in文件控制版本</li>
<li>增加QuickScript</li>
<li>优化QuickController初始化</li>
<li>QuickWork内部变量增加setter/getter</li>
<li>整理了下cmkae的example调用逻辑，方便后期增加案例</li>
</ol>
<hr />
<h3 id="14-更新301版本"><a class="header" href="#14-更新301版本">1.4. 更新3.0.1版本</a></h3>
<ol>
<li>增加若干案例</li>
<li>修复反射NewThread实例时，析构失败错误</li>
<li>优化详细打印</li>
<li>增加QuickController 增加排序注册</li>
</ol>
<hr />
<h3 id="15-3xx-版本计划"><a class="header" href="#15-3xx-版本计划">1.5. 3.X.X 版本计划</a></h3>
<ol>
<li>增加多个案例，展示<strong>QuickEvnet</strong>所有接口使用方式</li>
<li>修复3.0.0更新后引入的bug</li>
</ol>
<h1 id="5-examples介绍"><a class="header" href="#5-examples介绍">5 Examples介绍</a></h1>
<h3 id="11-example1完整功能展示"><a class="header" href="#11-example1完整功能展示">1.1. Example1：完整功能展示</a></h3>
<h3 id="12-example2自动实例化-quickapplicationquickwork-排序反射展示"><a class="header" href="#12-example2自动实例化-quickapplicationquickwork-排序反射展示">1.2. Example2：自动实例化 QuickApplication、QuickWork 排序反射展示</a></h3>
<pre><code class="language-cpp">----------------- QuickController Initialization:----------------- 
Lib Name: &quot;QuickEvent&quot; 
Lib VER: &quot;3.0.1&quot; 
Controlle QuickWorks: (&quot;High0&quot;, &quot;High1&quot;, &quot;High2&quot;, &quot;Disorder2&quot;, &quot;Disorder1&quot;, &quot;Disorder0&quot;, &quot;Low0&quot;, &quot;Low1&quot;, &quot;Low2&quot;) 
----------------------------------

&quot;High0  Initialization complete&quot;
&quot;High1  Initialization complete&quot;
&quot;High2  Initialization complete&quot;
&quot;Disorder2  Initialization complete&quot;
&quot;Disorder1  Initialization complete&quot;
&quot;Disorder0  Initialization complete&quot;
&quot;Low0  Initialization complete&quot;
&quot;Low1  Initialization complete&quot;
&quot;Low2  Initialization complete&quot;
&quot;High0  End of deconstruction&quot;
&quot;High1  End of deconstruction&quot;
&quot;High2  End of deconstruction&quot;
&quot;Disorder2  End of deconstruction&quot;
&quot;Disorder1  End of deconstruction&quot;
&quot;Disorder0  End of deconstruction&quot;
&quot;Low0  End of deconstruction&quot;
&quot;Low1  End of deconstruction&quot;
&quot;Low2  End of deconstruction&quot;
</code></pre>
<ul>
<li>注:1. Disorder反射乱序的,设计到有先后顺序需要注意</li>
</ul>
<h3 id="13-example3自动实例化-quickapplicationquickwork-线程归属展示"><a class="header" href="#13-example3自动实例化-quickapplicationquickwork-线程归属展示">1.3. Example3：自动实例化 QuickApplication、QuickWork 线程归属展示</a></h3>
<pre><code class="language-cpp">----------------- QuickController Initialization:----------------- 
Lib Name: &quot;QuickEvent&quot; 
Lib VER: &quot;3.0.1&quot; 
Controlle QuickWorks: (&quot;Disorder3&quot;, &quot;Disorder2&quot;, &quot;Disorder0&quot;, &quot;Disorder1&quot;) 
----------------------------------

Disorder3 Initialization QThread(0x1b9428d5fa0, name = &quot;Main Thread&quot;)
Disorder2 Initialization QThread(0x1b9428d5fa0, name = &quot;Main Thread&quot;)
Disorder0 Initialization QThread(0x1b9428d5fa0, name = &quot;Main Thread&quot;)
Disorder1 Initialization QThread(0x1b9428d5fa0, name = &quot;Main Thread&quot;)
Disorder0 Run QThread(0x1b9428d5fa0, name = &quot;Main Thread&quot;)
Disorder2 Run QThread(0x1b9428f94c0)
Disorder3 Run msleep Begin QThread(0x1b9428f9400, name = &quot;Work Thread&quot;)
Disorder3 Run msleep End QThread(0x1b9428f9400, name = &quot;Work Thread&quot;)
Disorder1 Run msleep Begin QThread(0x1b9428f9400, name = &quot;Work Thread&quot;)
Disorder1 Run msleep End QThread(0x1b9428f9400, name = &quot;Work Thread&quot;)
-------------quit-------------
&quot;Disorder2  End of deconstruction&quot;
&quot;Disorder3  End of deconstruction&quot;
&quot;Disorder1  End of deconstruction&quot;
&quot;Disorder0  End of deconstruction&quot;
</code></pre>
<ul>
<li>注:1. WorkThread下线程类似MainThread，阻塞依次执行</li>
</ul>
<h3 id="14-example4发布订阅--跨线程发布订阅"><a class="header" href="#14-example4发布订阅--跨线程发布订阅">1.4. Example4：发布订阅  跨线程发布订阅</a></h3>
<p>WorkThread的start耗时操作会阻塞所有WorkThread中订阅事件</p>
<pre><code class="language-cpp">----------------- QuickController Initialization:----------------- 
Lib Name: &quot;QuickEvent&quot; 
Lib VER: &quot;3.0.1&quot; 
Controlle QuickWorks: (&quot;MainThreadSubscibe&quot;, &quot;MainThreadPublish&quot;, &quot;NewThreadPublish&quot;, &quot;WorkThreadPublish&quot;, &quot;NewThreadSubscibe&quot;, &quot;WorkThreadSubscibe&quot;) 
----------------------------------

-------------Main Thread Publish-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example4&quot; 
Event ConnectionType: Qt::AutoConnection 
Event Args: Qt::AutoConnection 
Event Thread: QThread(0x20815dc6640, name = &quot;Main Thread&quot;) 
----------------------------------

MainThreadSubscibe QThread(0x20815dc6640, name = &quot;Main Thread&quot;)
NewThreadSubscibe QThread(0x20815df18b0)

-------------Work Thread Publish-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example4&quot; 
Event ConnectionType: Qt::AutoConnection 
Event Args: Qt::AutoConnection 
Event Thread: QThread(0x20815de8820, name = &quot;Work Thread&quot;) 
----------------------------------

WorkThreadSubscibe QThread(0x20815de8820, name = &quot;Work Thread&quot;)
MainThreadSubscibe QThread(0x20815dc6640, name = &quot;Main Thread&quot;)
NewThreadSubscibe QThread(0x20815df18b0)
WorkThreadSubscibe QThread(0x20815de8820, name = &quot;Work Thread&quot;)

-------------New Thread Publish-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example4&quot; 
Event ConnectionType: Qt::AutoConnection 
Event Args: Qt::AutoConnection 
Event Thread: QThread(0x20815de86c0) 
----------------------------------

MainThreadSubscibe QThread(0x20815dc6640, name = &quot;Main Thread&quot;)
NewThreadSubscibe QThread(0x20815df18b0)
WorkThreadSubscibe QThread(0x20815de8820, name = &quot;Work Thread&quot;)
-------------Quit-------------
</code></pre>
<ul>
<li>注:1. WorkThread的start耗时操作会阻塞所有WorkThread中订阅事件</li>
</ul>
<h3 id="15-example5发布订阅--多种发布展示同步异步异步等待自动"><a class="header" href="#15-example5发布订阅--多种发布展示同步异步异步等待自动">1.5. Example5：发布订阅  多种发布展示（同步、异步、异步等待、自动）</a></h3>
<pre><code class="language-cpp">----------------- QuickController Initialization:----------------- 
Lib Name: &quot;QuickEvent&quot; 
Lib VER: &quot;3.0.1&quot; 
Controlle QuickWorks: (&quot;NewThreadSubscibe1&quot;, &quot;NewThreadSubscibe2&quot;) 
----------------------------------


----------------- subscibeEvent:----------------- 
listener: NewThreadSubscibe1(0x23c34998610) 
Event name: &quot;Example5&quot; 
subscibe level Disorder 
Event Thread &quot;Main Thread&quot; 
----------------------------------


----------------- subscibeEvent:----------------- 
listener: NewThreadSubscibe2(0x23c34998950) 
Event name: &quot;Example5&quot; 
subscibe level Disorder 
Event Thread &quot;Main Thread&quot; 
----------------------------------


-------------Direct PUBLISH-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example5&quot; 
Event ConnectionType: Qt::DirectConnection 
Event Args: Qt::DirectConnection 
Event Thread: QThread(0x23c34976690, name = &quot;Main Thread&quot;) 
----------------------------------

New1 Subscibe bugin QThread(0x23c34998570)
New2 Subscibe bugin QThread(0x23c349988d0)
New2 Subscibe end QThread(0x23c349988d0)
New1 Subscibe end QThread(0x23c34998570)

-------------Queued PUBLISH-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example5&quot; 
Event ConnectionType: Qt::QueuedConnection 
Event Args: Qt::QueuedConnection 
Event Thread: QThread(0x23c34976690, name = &quot;Main Thread&quot;) 
----------------------------------

New1 Subscibe bugin QThread(0x23c34998570)
New2 Subscibe bugin QThread(0x23c349988d0)
New2 Subscibe end QThread(0x23c349988d0)
New1 Subscibe end QThread(0x23c34998570)

-------------Blocking Queued PUBLISH-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example5&quot; 
Event ConnectionType: Qt::BlockingQueuedConnection 
Event Args: Qt::BlockingQueuedConnection 
Event Thread: QThread(0x23c34976690, name = &quot;Main Thread&quot;) 
----------------------------------

New1 Subscibe bugin QThread(0x23c34998570)
New1 Subscibe end QThread(0x23c34998570)
New2 Subscibe bugin QThread(0x23c349988d0)
New2 Subscibe end QThread(0x23c349988d0)

-------------Auto PUBLISH1-------------

----------------- publishEvent:----------------- 
Event name:  &quot;Example5&quot; 
Event ConnectionType: Qt::AutoConnection 
Event Args: Qt::AutoConnection 
Event Thread: QThread(0x23c34976690, name = &quot;Main Thread&quot;) 
----------------------------------

New1 Subscibe bugin QThread(0x23c34998570)
New2 Subscibe bugin QThread(0x23c349988d0)
New2 Subscibe end QThread(0x23c349988d0)
New1 Subscibe end QThread(0x23c34998570)
-------------Quit-------------
&quot;NewThreadSubscibe1  End of deconstruction&quot;
&quot;NewThreadSubscibe2  End of deconstruction&quot;
</code></pre>
<ul>
<li>注:1. 小心死锁，尤其跨线程阻塞同步、带QDialog等有返回值的窗口请勿使用阻塞发布</li>
</ul>
<h3 id="16-持续增加中"><a class="header" href="#16-持续增加中">1.6. 。。。。持续增加中</a></h3>
<h1 id="6-quickevnet代码模型使用心得"><a class="header" href="#6-quickevnet代码模型使用心得">6 QuickEvnet代码模型使用心得</a></h1>
<h1 id="7-关于作者"><a class="header" href="#7-关于作者">7 关于作者</a></h1>
<p><strong>Bruce</strong><br />
Gitee
https://gitee.com/fmldd<br />
个人博客<br />
https://me.csdn.net/dadabruce</p>
<p><strong>Beyond欣</strong><br />
Gitee<br />
https://gitee.com/yaoxin001<br />
个人博客<br />
http://118.25.63.144</p>
<hr />
<p>本文仓库  <a href="https://gitee.com/fmldd/Quick-Event">https://gitee.com/fmldd/Quick-Event</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../开源项目/OpenBrowser.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../开源项目/GithubImageHost.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../开源项目/OpenBrowser.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../开源项目/GithubImageHost.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
