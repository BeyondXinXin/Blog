# 21-7、8、9






# VTK：IO-三维文件格式之ConvertFile

## 描述

This example demonstrates how to read a file and then write it to a different type of file. In this example, we read a vtp file and write a ply file, but simply by changing the reader/writer classes instantiated, different behavior can be achieved.

此示例演示如何读取文件，然后将其写入不同类型的文件。在本例中，我们读取vtp文件并编写ply文件，但只需更改实例化的reader/writer类，就可以实现不同的行为。
## 代码
ConvertFile.cxx
```cpp
#include <vtkNew.h>
#include <vtkPLYWriter.h>
#include <vtkPolyData.h>
#include <vtkXMLPolyDataReader.h>

int main(int argc, char* argv[])
{
  if (argc < 3)
  {
    std::cerr << "Required arguments: input.vtp output.ply e.g. Bunny.vtp "
                 "ConvertFile.ply"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string inputFileName = argv[1];
  std::string outputFileName = argv[2];

  vtkNew<vtkXMLPolyDataReader> reader;
  reader->SetFileName(inputFileName.c_str());
  reader->Update();

  vtkNew<vtkPLYWriter> writer;
  writer->SetFileName(outputFileName.c_str());
  writer->SetInputConnection(reader->GetOutputPort());
  writer->Update();

  return EXIT_SUCCESS;
}
```

CMakeLists.txt

```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ConvertFile)

find_package(VTK COMPONENTS 
  vtkCommonCore
  vtkCommonDataModel
  vtkIOPLY
  vtkIOXML
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ConvertFile: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ConvertFile MACOSX_BUNDLE ConvertFile.cxx )
  target_link_libraries(ConvertFile PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ConvertFile MACOSX_BUNDLE ConvertFile.cxx )
  target_link_libraries(ConvertFile PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ConvertFile
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```



# VTK：IO-三维文件格式之XGMLReader

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/InfoVis/TestXGMLReader.png?raw=true)


## 描述

This example reads and displays the graph from a gml file.

本例从gml文件读取并显示图形。
## 代码

XGMLReader.cxx
```cpp
#include <vtkGraphLayoutStrategy.h>
#include <vtkGraphLayoutView.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyData.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSimple2DLayoutStrategy.h>
#include <vtkUndirectedGraph.h>
#include <vtkViewTheme.h>
#include <vtkXGMLReader.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc != 2)
  {
    std::cout << "Required parameters: Filename e.g. fsm.gml" << std::endl;
    return EXIT_FAILURE;
  }

  std::string inputFilename = argv[1];

  vtkNew<vtkXGMLReader> reader;
  reader->SetFileName(inputFilename.c_str());
  reader->Update();

  vtkUndirectedGraph* g = reader->GetOutput();

  vtkNew<vtkViewTheme> theme;
  theme->SetLineWidth(1);
  theme->SetPointSize(5);
  theme->SetCellOpacity(0.99);
  theme->SetOutlineColor(colors->GetColor3d("Gray").GetData());
  // Vertices
  theme->SetPointColor(colors->GetColor3d("Chartreuse").GetData());
  theme->SetSelectedPointColor(colors->GetColor3d("Magenta").GetData());
  theme->SetPointHueRange(1.0, 1.0);
  theme->SetPointSaturationRange(1.0, 1.0);
  theme->SetPointValueRange(0.0, 1.0);
  // theme->SetPointAlphaRange(0.2, 0.8);
  // Edges
  theme->SetCellColor(colors->GetColor3d("Honeydew").GetData());
  theme->SetSelectedCellColor(colors->GetColor3d("Cyan").GetData());
  theme->SetCellHueRange(0.1, 0.1);
  theme->SetCellSaturationRange(0.2, 1.0);
  theme->SetCellValueRange(0.5, 1.0);
  // theme->SetCellAlphaRange(0.2, 0.8);

  vtkNew<vtkSimple2DLayoutStrategy> simple2D;

  vtkNew<vtkGraphLayoutView> graphLayoutView;
  graphLayoutView->AddRepresentationFromInput(g);
  graphLayoutView->ApplyViewTheme(theme);
  // If we create a layout object directly, just set the pointer to this method.
  // graphLayoutView->SetLayoutStrategy(simple2D);
  graphLayoutView->SetLayoutStrategyToSimple2D();

  graphLayoutView->ResetCamera();

  graphLayoutView->GetRenderer()->GradientBackgroundOn();
  graphLayoutView->GetRenderer()->SetBackground2(
      colors->GetColor3d("DarkSlateGray").GetData());
  graphLayoutView->GetRenderer()->SetBackground(
      colors->GetColor3d("Black").GetData());

  graphLayoutView->GetRenderWindow()->SetSize(600, 600);
  graphLayoutView->GetRenderWindow()->SetWindowName("XGMLReader");

  graphLayoutView->Render();

  graphLayoutView->GetInteractor()->Start();

  return EXIT_SUCCESS;
}
```

CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(XGMLReader)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkIOInfovis
  vtkInfovisLayout
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  vtkViewsCore
  vtkViewsInfovis
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping XGMLReader: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(XGMLReader MACOSX_BUNDLE XGMLReader.cxx )
  target_link_libraries(XGMLReader PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(XGMLReader MACOSX_BUNDLE XGMLReader.cxx )
  target_link_libraries(XGMLReader PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS XGMLReader
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```






# VTK：IO-标准格式之 DEMReader

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestDEMReader.png?raw=true)

## 描述

## 代码

```cpp
#include <vtkDEMReader.h>
#include <vtkImageActor.h>
#include <vtkImageData.h>
#include <vtkImageMapToColors.h>
#include <vtkImageMapper3D.h>
#include <vtkInteractorStyleImage.h>
#include <vtkLookupTable.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  // Verify arguments
  if (argc < 2)
  {
    std::cerr << "Required: filename.dem e.g. SainteHelens.dem" << std::endl;
    return EXIT_FAILURE;
  }

  // Read the file
  vtkNew<vtkDEMReader> reader;
  reader->SetFileName(argv[1]);
  reader->Update();

  vtkNew<vtkLookupTable> lut;
  lut->SetHueRange(0.6, 0);
  lut->SetSaturationRange(1.0, 0);
  lut->SetValueRange(0.5, 1.0);
  lut->SetTableRange(reader->GetOutput()->GetScalarRange());

  // Visualize
  vtkNew<vtkImageMapToColors> mapColors;
  mapColors->SetLookupTable(lut);
  mapColors->SetInputConnection(reader->GetOutputPort());

  // Create an actor
  vtkNew<vtkImageActor> actor;
  actor->GetMapper()->SetInputConnection(mapColors->GetOutputPort());

  // Setup renderer
  vtkNew<vtkRenderer> renderer;
  renderer->AddActor(actor);
  renderer->ResetCamera();
  renderer->SetBackground(colors->GetColor3d("SlateGray").GetData());

  // Setup render window
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("DEMReader");

  // Setup render window interactor
  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  vtkNew<vtkInteractorStyleImage> style;

  renderWindowInteractor->SetInteractorStyle(style);

  // Render and start interaction
  renderWindowInteractor->SetRenderWindow(renderWindow);
  renderWindow->Render();
  renderWindowInteractor->Initialize();

  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(DEMReader)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkIOImage
  vtkImagingCore
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping DEMReader: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(DEMReader MACOSX_BUNDLE DEMReader.cxx )
  target_link_libraries(DEMReader PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(DEMReader MACOSX_BUNDLE DEMReader.cxx )
  target_link_libraries(DEMReader PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS DEMReader
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 DelimitedTextReader

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/InfoVis/TestDelimitedTextReader.png?raw=true)

## 描述

This example takes a plain text file of coordinates and normals (x y z nx ny nz) and reads them into a vtkPolyData and displays them on the screen. This can be easily changed to reading a file with any delimiter by changing the argument of Reader->SetFieldDelimiterCharacters(" ");

Here is an example file:
本例采用坐标和法线（x y z nx ny nz）的纯文本文件，将它们读入vtkPolyData并在屏幕上显示。通过更改Reader->SetFieldDelimiterCharacters（“”）的参数，可以很容易地将其更改为读取带有任何分隔符的文件；

下面是一个示例文件：



## 代码
```cpp
 0.0 0.0 0.0 1.0 2.0 3.0
 1.0 0.0 0.0 4.0 5.0 6.1
 0.0 1.0 0.0 7.2 8.3 9.4
 ```

!!! question
    If you have a question about this example, please use the [VTK Discourse Forum](https://discourse.vtk.org/)

###Code
**DelimitedTextReader.cxx**
``` c++ hl_lines="1 2 3 4 5 6 7 8 9 10 11 12 13 14 18 30 36 38 39 48 70 74 79 82 87 88 92"

#include <vtkActor.h>
#include <vtkDelimitedTextReader.h>
#include <vtkDoubleArray.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPointData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkTable.h>
#include <vtkVersionMacros.h> // For version macros
#include <vtkVertexGlyphFilter.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  // Verify input arguments
  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << " Filename e.g DelimitedData.txt"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string inputFilename = argv[1];

  vtkNew<vtkDelimitedTextReader> reader;
  reader->SetFileName(inputFilename.c_str());
  reader->DetectNumericColumnsOn();
  reader->SetFieldDelimiterCharacters(" ");
  reader->Update();

  vtkTable* table = reader->GetOutput();

  vtkNew<vtkPoints> points;
  vtkNew<vtkDoubleArray> normals;

  normals->SetNumberOfComponents(3); // 3d normals (ie x,y,z)

  std::cout << "Table has " << table->GetNumberOfRows() << " rows."
            << std::endl;
  std::cout << "Table has " << table->GetNumberOfColumns() << " columns."
            << std::endl;

  for (vtkIdType i = 0; i < table->GetNumberOfRows(); i++)
  {
    std::cout << "x: " << (table->GetValue(i, 0)).ToDouble()
              << " y: " << (table->GetValue(i, 1)).ToDouble()
              << " z: " << (table->GetValue(i, 2)).ToDouble();

    points->InsertNextPoint((table->GetValue(i, 0)).ToDouble(),
                            (table->GetValue(i, 1)).ToDouble(),
                            (table->GetValue(i, 2)).ToDouble());

    double n[3];
    n[0] = (table->GetValue(i, 3)).ToDouble();
    n[1] = (table->GetValue(i, 4)).ToDouble();
    n[2] = (table->GetValue(i, 5)).ToDouble();

    std::cout << " n: " << n[0] << " " << n[1] << " " << n[2] << std::endl;
    normals->InsertNextTuple(n);
  }

  std::cout << "There are " << points->GetNumberOfPoints() << " points."
            << std::endl;

  vtkNew<vtkPolyData> polydata;
  polydata->SetPoints(points);
  polydata->GetPointData()->SetNormals(normals);

  vtkNew<vtkVertexGlyphFilter> glyphFilter;
  glyphFilter->SetInputData(polydata);
  glyphFilter->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(glyphFilter->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetPointSize(30);
  actor->GetProperty()->SetColor(colors->GetColor3d("Tomato").GetData());

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("DelimitedTextReader");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("Mint").GetData());

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(DelimitedTextReader)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkFiltersGeneral
  vtkIOInfovis
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping DelimitedTextReader: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(DelimitedTextReader MACOSX_BUNDLE DelimitedTextReader.cxx )
  target_link_libraries(DelimitedTextReader PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(DelimitedTextReader MACOSX_BUNDLE DelimitedTextReader.cxx )
  target_link_libraries(DelimitedTextReader PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS DelimitedTextReader
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 DumpXMLFile

![]()


## 描述

This example reports the cell, cell data and point data contained within a VTK XML or legacy file.
此示例报告VTK XML或旧文件中包含的单元、单元数据和点数据。

## 代码

DumpXMLFile.cxx
```cpp
//
// DumpXMLFile - report on the contents of an XML or legacy vtk file
//  Usage: DumpXMLFile XMLFile1 XMLFile2 ...
//         where
//         XMLFile is a vtk XML file of type .vtu, .vtp, .vts, .vtr,
//         .vti, .vto
//
#include <vtkCellData.h>
#include <vtkCellTypes.h>
#include <vtkDataSet.h>
#include <vtkDataSetReader.h>
#include <vtkFieldData.h>
#include <vtkImageData.h>
#include <vtkNew.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>
#include <vtkSmartPointer.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkXMLCompositeDataReader.h>
#include <vtkXMLImageDataReader.h>
#include <vtkXMLPolyDataReader.h>
#include <vtkXMLReader.h>
#include <vtkXMLRectilinearGridReader.h>
#include <vtkXMLStructuredGridReader.h>
#include <vtkXMLUnstructuredGridReader.h>
#include <vtksys/SystemTools.hxx>

#include <map>

namespace {

template <class TReader> vtkDataSet* ReadAnXMLFile(const char* fileName)
{
  vtkNew<TReader> reader;
  reader->SetFileName(fileName);
  reader->Update();
  reader->GetOutput()->Register(reader);
  return dynamic_cast<vtkDataSet*>(reader->GetOutput());
}

} // namespace

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: " << argv[0] << " XMLFile1 XMLFile2 ..." << std::endl;
    return EXIT_FAILURE;
  }

  // Process each file on the command line
  int f = 1;
  while (f < argc)
  {
    vtkSmartPointer<vtkDataSet> dataSet;
    std::string extension =
        vtksys::SystemTools::GetFilenameLastExtension(argv[f]);
    // Dispatch based on the file extension
    if (extension == ".vtu")
    {
      dataSet = ReadAnXMLFile<vtkXMLUnstructuredGridReader>(argv[f]);
    }
    else if (extension == ".vtp")
    {
      dataSet = ReadAnXMLFile<vtkXMLPolyDataReader>(argv[f]);
    }
    else if (extension == ".vts")
    {
      dataSet = ReadAnXMLFile<vtkXMLStructuredGridReader>(argv[f]);
    }
    else if (extension == ".vtr")
    {
      dataSet = ReadAnXMLFile<vtkXMLRectilinearGridReader>(argv[f]);
    }
    else if (extension == ".vti")
    {
      dataSet = ReadAnXMLFile<vtkXMLImageDataReader>(argv[f]);
    }
    else if (extension == ".vtk")
    {
      dataSet = ReadAnXMLFile<vtkDataSetReader>(argv[f]);
    }
    else
    {
      std::cerr << argv[0] << " Unknown extension: " << extension << std::endl;
      return EXIT_FAILURE;
    }

    int numberOfCells = dataSet->GetNumberOfCells();
    int numberOfPoints = dataSet->GetNumberOfPoints();

    // Generate a report
    std::cout << "------------------------" << std::endl;
    std::cout << argv[f] << std::endl
              << " contains a " << std::endl
              << dataSet->GetClassName() << " that has " << numberOfCells
              << " cells"
              << " and " << numberOfPoints << " points." << std::endl;
    typedef std::map<int, int> CellContainer;
    CellContainer cellMap;
    for (int i = 0; i < numberOfCells; i++)
    {
      cellMap[dataSet->GetCellType(i)]++;
    }

    CellContainer::const_iterator it = cellMap.begin();
    while (it != cellMap.end())
    {
      std::cout << "\tCell type "
                << vtkCellTypes::GetClassNameFromTypeId(it->first) << " occurs "
                << it->second << " times." << std::endl;
      ++it;
    }

    // Now check for point data
    vtkPointData* pd = dataSet->GetPointData();
    if (pd)
    {
      std::cout << " contains point data with " << pd->GetNumberOfArrays()
                << " arrays." << std::endl;
      for (int i = 0; i < pd->GetNumberOfArrays(); i++)
      {
        std::cout << "\tArray " << i << " is named "
                  << (pd->GetArrayName(i) ? pd->GetArrayName(i) : "NULL")
                  << " has " << pd->GetArray(i)->GetNumberOfTuples()
                  << " tuples"
                  << " with " << pd->GetArray(i)->GetNumberOfComponents()
                  << " components"
                  << " of type " << pd->GetArray(i)->GetClassName()
                  << std::endl;
      }
    }

    // Now check for cell data
    vtkCellData* cd = dataSet->GetCellData();
    if (cd)
    {
      std::cout << " contains cell data with " << cd->GetNumberOfArrays()
                << " arrays." << std::endl;
      for (int i = 0; i < cd->GetNumberOfArrays(); i++)
      {
        std::cout << "\tArray " << i << " is named "
                  << (cd->GetArrayName(i) ? cd->GetArrayName(i) : "NULL")
                  << std::endl;
      }
    }

    // Now check for field data
    if (dataSet->GetFieldData())
    {
      std::cout << " contains field data with "
                << dataSet->GetFieldData()->GetNumberOfArrays() << " arrays."
                << std::endl;
      for (int i = 0; i < dataSet->GetFieldData()->GetNumberOfArrays(); i++)
      {
        std::cout
            << "\tArray " << i << " is named "
            << dataSet->GetFieldData()->GetArray(i)->GetName() << " has "
            << dataSet->GetFieldData()->GetArray(i)->GetNumberOfTuples()
            << " tuples"
            << " with "
            << dataSet->GetFieldData()->GetArray(i)->GetNumberOfComponents()
            << " components"
            << " of type "
            << dataSet->GetFieldData()->GetArray(i)->GetClassName()
            << std::endl;
      }
    }
    f++;
  }
  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(DumpXMLFile)

find_package(VTK COMPONENTS 
  vtkCommonCore
  vtkCommonDataModel
  vtkIOLegacy
  vtkIOXML
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping DumpXMLFile: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(DumpXMLFile MACOSX_BUNDLE DumpXMLFile.cxx )
  target_link_libraries(DumpXMLFile PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(DumpXMLFile MACOSX_BUNDLE DumpXMLFile.cxx )
  target_link_libraries(DumpXMLFile PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS DumpXMLFile
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```


# VTK：IO-标准格式之 IndividualVRML

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestIndividualVRML.png?raw=true)


## 描述

This example shows how to obtain each object of a scene and get it's initial transformation. The selected actor is represented in wireframe. To run this example:
这个例子展示了如何获得场景中的每个对象并获得它的初始变换。选定的参与者用线框表示。要运行此示例：

> IndividualVRML filename actorname

The .wrl file must contain a Shape with a DEF name.
.wrl文件必须包含具有DEF名称的形状。


## 代码
IndividualVRML.cxx
```cpp
#include <vtkAxesActor.h>
#include <vtkCamera.h>
#include <vtkDataSet.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyData.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkTransform.h>
#include <vtkVRMLImporter.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc != 3)
  {
    std::cout << "Required arguments: Filename Actorname e.g. teapot.wrl teapot"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string filename = argv[1];
  std::cout << "Showing " << argv[2] << " from " << filename << std::endl;

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("IndividualVRML");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  // VRML Import
  vtkNew<vtkVRMLImporter> importer;
  importer->SetFileName(filename.c_str());
  importer->Read();
  importer->SetRenderWindow(renderWindow);
  importer->Update();

  // ----------------------------------------------------------
  vtkObject* defActor = importer->GetVRMLDEFObject(argv[2]);
  if (defActor == NULL)
  {
    std::cout << "Cannot locate actor " << argv[2] << " in " << filename
              << std::endl;
    importer->Print(std::cout);
    return EXIT_FAILURE;
  }

  vtkActor* actor = static_cast<vtkActor*>(defActor);
  double color[3] = {0.89, 0.81, 0.34};
  actor->GetProperty()->SetColor(colors->GetColor3d("Gold").GetData());
  actor->GetProperty()->SetRepresentationToWireframe();

  vtkNew<vtkTransform> transform;

  transform->Translate(actor->GetCenter()[0], actor->GetCenter()[1],
                       actor->GetCenter()[2]);
  // axes
  vtkNew<vtkAxesActor> axes;

  double l[3];
  l[0] = (actor->GetBounds()[1] - actor->GetBounds()[0]) * 1.5;
  l[1] = (actor->GetBounds()[3] - actor->GetBounds()[2]) * 1.5;
  l[2] = (actor->GetBounds()[5] - actor->GetBounds()[4]) * 1.5;

  axes->SetTotalLength(l);
  axes->SetUserTransform(transform);
  renderer->AddActor(axes);
  renderer->SetBackground(colors->GetColor3d("MidnightBlue").GetData());
  renderWindow->Render();

  renderer->GetActiveCamera()->SetPosition(-14.8296, 18.1304, 12.3352);
  renderer->GetActiveCamera()->SetFocalPoint(2.09905, 0.0832915, 2.47961);
  renderer->GetActiveCamera()->SetViewUp(0.262918, -0.260671, 0.928937);
  renderer->GetActiveCamera()->SetDistance(26.6348);
  renderer->ResetCameraClippingRange();

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(IndividualVRML)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkCommonTransforms
  vtkIOImport
  vtkInteractionStyle
  vtkRenderingAnnotation
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping IndividualVRML: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(IndividualVRML MACOSX_BUNDLE IndividualVRML.cxx )
  target_link_libraries(IndividualVRML PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(IndividualVRML MACOSX_BUNDLE IndividualVRML.cxx )
  target_link_libraries(IndividualVRML PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS IndividualVRML
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ParticleReader

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestParticleReader.png?raw=true)


## 描述

This example reads ascii files where each line consists of points with its position (x,y,z) and (optionally) one scalar or binary files in RAW 3d file format.

此示例读取ascii文件，其中每条线由点及其位置（x、y、z）和（可选）一个原始三维文件格式的标量或二进制文件组成。
## 代码
ParticleReader.cxx

```cpp
//
// This example reads ascii files where each line consists of points with its
// position (x,y,z) and (optionally) one scalar or binary files in RAW 3d file
// format.
//
// some standard vtk headers
#include <vtkActor.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkParticleReader.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

// needed to easily convert int to std::string
int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  // Verify input arguments
  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << " Filename(.raw) e.g. Particles.raw"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string filePath = argv[1];
  // Particles.raw supplied by VTK is big endian encoded
  // std::string filePath = "C:\\VTK\\vtkdata-5.8.0\\Data\\Particles.raw";
  // Read the file
  vtkNew<vtkParticleReader> reader;

  reader->SetFileName(filePath.c_str());
  // if nothing gets displayed or totally wrong, swap the endianness
  reader->SetDataByteOrderToBigEndian();
  reader->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(reader->GetOutputPort());
  std::cout << "number of pieces: " << mapper->GetNumberOfPieces() << std::endl;
  mapper->SetScalarRange(4, 9);

  vtkNew<vtkActor> actor;

  actor->SetMapper(mapper);
  actor->GetProperty()->SetPointSize(4);

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("ParticleReader");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("DarkSlateGray").GetData());

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ParticleReader)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkIOGeometry
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ParticleReader: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ParticleReader MACOSX_BUNDLE ParticleReader.cxx )
  target_link_libraries(ParticleReader PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ParticleReader MACOSX_BUNDLE ParticleReader.cxx )
  target_link_libraries(ParticleReader PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ParticleReader
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadAllPolyDataTypes

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadAllPolyDataTypes.png?raw=true)


## 描述


This example selects the vtkPolyData reader by inspecting the extension of the file. The example processes every file passed as an argument. This assumes all of the files are modeled in the same coordinate system.
本例通过检查文件的扩展名来选择vtkPolyData读取器。该示例处理作为参数传递的每个文件。这假设所有文件都在同一坐标系中建模。

## 代码

ReadAllPolyDataTypes.cxx
```cpp
#include <vtkBYUReader.h>
#include <vtkOBJReader.h>
#include <vtkPLYReader.h>
#include <vtkPolyDataReader.h>
#include <vtkSTLReader.h>
#include <vtkXMLPolyDataReader.h>

#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkNamedColors.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSmartPointer.h>
#include <vtkSphereSource.h>
#include <vtkTimerLog.h>
#include <vtksys/SystemTools.hxx>

#include <algorithm>
#include <array>
#include <random>
#include <string>

namespace {
vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName);
}

int main(int argc, char* argv[])
{
  // Vis Pipeline
  vtkNew<vtkNamedColors> colors;

  vtkNew<vtkRenderer> renderer;

  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->SetSize(640, 480);
  renderWindow->AddRenderer(renderer);

  vtkNew<vtkRenderWindowInteractor> interactor;
  interactor->SetRenderWindow(renderWindow);

  renderer->SetBackground(colors->GetColor3d("Wheat").GetData());
  renderer->UseHiddenLineRemovalOn();

  // Note: If a Python version is written, it is probably best to use
  //       vtkMinimalStandardRandomSequence in it and here, to ensure
  //       that the random number generation is the same.
  std::mt19937 mt(4355412); // Standard mersenne_twister_engine
  std::uniform_real_distribution<double> distribution(0.6, 1.0);

  // PolyData file pipeline
  for (int i = 1; i < argc; ++i)
  {
    std::cout << "Loading: " << argv[i] << std::endl;
    auto polyData = ReadPolyData(argv[i]);

    // Visualize
    vtkNew<vtkPolyDataMapper> mapper;
    mapper->SetInputData(polyData);

    std::array<double, 3> randomColor;
    randomColor[0] = distribution(mt);
    randomColor[1] = distribution(mt);
    randomColor[2] = distribution(mt);
    vtkNew<vtkProperty> backProp;
    backProp->SetDiffuseColor(colors->GetColor3d("Banana").GetData());
    backProp->SetSpecular(0.6);
    backProp->SetSpecularPower(30);

    vtkNew<vtkActor> actor;
    actor->SetMapper(mapper);
    actor->SetBackfaceProperty(backProp);
    actor->GetProperty()->SetDiffuseColor(randomColor.data());
    actor->GetProperty()->SetSpecular(0.3);
    actor->GetProperty()->SetSpecularPower(30);
    renderer->AddActor(actor);
  }

  renderWindow->SetWindowName("ReadAllPolyDataTypes");
  renderWindow->Render();
  interactor->Start();

  return EXIT_SUCCESS;
}

namespace {
vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName)
{
  vtkSmartPointer<vtkPolyData> polyData;
  std::string extension =
      vtksys::SystemTools::GetFilenameLastExtension(std::string(fileName));

  // Drop the case of the extension
  std::transform(extension.begin(), extension.end(), extension.begin(),
                 ::tolower);

  if (extension == ".ply")
  {
    vtkNew<vtkPLYReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".vtp")
  {
    vtkNew<vtkXMLPolyDataReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".obj")
  {
    vtkNew<vtkOBJReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".stl")
  {
    vtkNew<vtkSTLReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".vtk")
  {
    vtkNew<vtkPolyDataReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".g")
  {
    vtkNew<vtkBYUReader> reader;
    reader->SetGeometryFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else
  {
    vtkNew<vtkSphereSource> source;
    source->Update();
    polyData = source->GetOutput();
  }

  return polyData;
}
} // namespace
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadAllPolyDataTypes)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonSystem
  vtkFiltersSources
  vtkIOGeometry
  vtkIOLegacy
  vtkIOPLY
  vtkIOXML
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadAllPolyDataTypes: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadAllPolyDataTypes MACOSX_BUNDLE ReadAllPolyDataTypes.cxx )
  target_link_libraries(ReadAllPolyDataTypes PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadAllPolyDataTypes MACOSX_BUNDLE ReadAllPolyDataTypes.cxx )
  target_link_libraries(ReadAllPolyDataTypes PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadAllPolyDataTypes
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadAllPolyDataTypesDemo	

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadAllPolyDataTypesDemo.png?raw=true)


## 描述


This example displays a model from each of the supported vtkPolyData readers.
此示例显示每个受支持的vtkPolyData读取器的模型。

## 代码

ReadAllPolyDataTypesDemo.cxx

```cpp
#include <vtkActor.h>
#include <vtkActor2D.h>
#include <vtkBYUReader.h>
#include <vtkCamera.h>
#include <vtkCellArray.h>
#include <vtkCoordinate.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkOBJReader.h>
#include <vtkPLYReader.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkPolyDataMapper2D.h>
#include <vtkPolyDataReader.h>
#include <vtkPolyLine.h>
#include <vtkProperty.h>
#include <vtkProperty2D.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSTLReader.h>
#include <vtkSmartPointer.h>
#include <vtkSphereSource.h>
#include <vtkTextMapper.h>
#include <vtkTextProperty.h>
#include <vtkTimerLog.h>
#include <vtkXMLPolyDataReader.h>

#include <vtksys/SystemTools.hxx>

#include <algorithm>
#include <string>

namespace {
vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName);

void ViewportBorder(vtkSmartPointer<vtkRenderer>& renderer, double* color,
                    bool last = false);
} // namespace

int main(int argc, char* argv[])
{
  // Visualize
  vtkNew<vtkNamedColors> colors;

  // Create one text property for all
  vtkNew<vtkTextProperty> textProperty;
  textProperty->SetFontSize(16);
  textProperty->SetColor(0.3, 0.3, 0.3);

  // Setup render window
  vtkNew<vtkRenderWindow> renderWindow;
  std::vector<vtkSmartPointer<vtkRenderer>> renderers;
  for (auto i = 1; i < argc; ++i)
  {
    std::cout << argv[i] << std::endl;
    auto polyData = ReadPolyData(argv[i]);
    vtkNew<vtkPolyDataMapper> mapper;
    mapper->SetInputData(polyData);

    vtkNew<vtkActor> actor;
    actor->SetMapper(mapper);
    actor->GetProperty()->SetDiffuseColor(
        colors->GetColor3d("Light_salmon").GetData());
    actor->GetProperty()->SetSpecular(0.6);
    actor->GetProperty()->SetSpecularPower(30);

    // Create textActors
    vtkNew<vtkTextMapper> textMapper;
    textMapper->SetTextProperty(textProperty);
    textMapper->SetInput(vtksys::SystemTools::GetFilenameName(argv[i]).c_str());

    vtkNew<vtkActor2D> textActor;
    textActor->SetMapper(textMapper);
    textActor->SetPosition(20, 20);

    // Setup renderer
    vtkNew<vtkRenderer> renderer;
    renderer->AddActor(actor);
    renderer->AddActor(textActor);
    renderer->SetBackground(colors->GetColor3d("mint").GetData());
    renderers.push_back(renderer);
    renderWindow->AddRenderer(renderer);
  }

  // Setup viewports for the renderers
  auto rendererSize = 400;
  auto xGridDimensions = 3;
  auto yGridDimensions = 2;
  yGridDimensions = argc / xGridDimensions;
  renderWindow->SetSize(rendererSize * xGridDimensions,
                        rendererSize * yGridDimensions);
  auto blank = argc - 1 + ((argc - 1) % xGridDimensions);
  for (auto i = argc; i < blank; ++i)
  {
    vtkNew<vtkRenderer> renderer;
    renderer->SetBackground(colors->GetColor3d("White").GetData());
    renderers.push_back(renderer);
    renderWindow->AddRenderer(renderer);
  }

  for (auto row = 0; row < yGridDimensions; row++)
  {
    for (auto col = 0; col < xGridDimensions; col++)
    {
      auto index = row * xGridDimensions + col;

      // (xmin, ymin, xmax, ymax)
      double viewport[4] = {static_cast<double>(col) * rendererSize /
                                (xGridDimensions * rendererSize),
                            static_cast<double>(yGridDimensions - (row + 1)) *
                                rendererSize / (yGridDimensions * rendererSize),
                            static_cast<double>(col + 1) * rendererSize /
                                (xGridDimensions * rendererSize),
                            static_cast<double>(yGridDimensions - row) *
                                rendererSize /
                                (yGridDimensions * rendererSize)};
      renderers[index]->SetViewport(viewport);
      ViewportBorder(renderers[index],
                     colors->GetColor3d("SlateGray").GetData(),
                     col == static_cast<int>(xGridDimensions));
    }
  }
  vtkNew<vtkRenderWindowInteractor> interactor;
  interactor->SetRenderWindow(renderWindow);

  renderWindow->SetWindowName("ReadAllPolyDataTypesDemo");
  renderWindow->Render();
  interactor->Start();

  return EXIT_SUCCESS;
}

namespace {

vtkSmartPointer<vtkPolyData> ReadPolyData(const char* fileName)
{
  vtkSmartPointer<vtkPolyData> polyData;
  std::string extension =
      vtksys::SystemTools::GetFilenameLastExtension(std::string(fileName));

  // Drop the case of the extension
  std::transform(extension.begin(), extension.end(), extension.begin(),
                 ::tolower);

  if (extension == ".ply")
  {
    vtkNew<vtkPLYReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".vtp")
  {
    vtkNew<vtkXMLPolyDataReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".obj")
  {
    vtkNew<vtkOBJReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".stl")
  {
    vtkNew<vtkSTLReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".vtk")
  {
    vtkNew<vtkPolyDataReader> reader;
    reader->SetFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else if (extension == ".g")
  {
    vtkNew<vtkBYUReader> reader;
    reader->SetGeometryFileName(fileName);
    reader->Update();
    polyData = reader->GetOutput();
  }
  else
  {
    vtkNew<vtkSphereSource> source;
    source->Update();
    polyData = source->GetOutput();
  }
  return polyData;
}

// draw the borders of a renderer's viewport
void ViewportBorder(vtkSmartPointer<vtkRenderer>& renderer, double* color,
                    bool last)
{
  // points start at upper right and proceed anti-clockwise
  vtkNew<vtkPoints> points;
  points->SetNumberOfPoints(4);
  points->InsertPoint(0, 1, 1, 0);
  points->InsertPoint(1, 0, 1, 0);
  points->InsertPoint(2, 0, 0, 0);
  points->InsertPoint(3, 1, 0, 0);

  // create cells, and lines
  vtkNew<vtkCellArray> cells;
  cells->Initialize();

  vtkNew<vtkPolyLine> lines;

  // only draw last line if this is the last viewport
  // this prevents double vertical lines at right border
  // if different colors are used for each border, then do
  // not specify last
  if (last)
  {
    lines->GetPointIds()->SetNumberOfIds(5);
  }
  else
  {
    lines->GetPointIds()->SetNumberOfIds(4);
  }
  for (unsigned int i = 0; i < 4; ++i)
  {
    lines->GetPointIds()->SetId(i, i);
  }
  if (last)
  {
    lines->GetPointIds()->SetId(4, 0);
  }
  cells->InsertNextCell(lines);

  // now make the polydata and display it
  vtkNew<vtkPolyData> poly;
  poly->Initialize();
  poly->SetPoints(points);
  poly->SetLines(cells);

  // use normalized viewport coordinates since
  // they are independent of window size
  vtkNew<vtkCoordinate> coordinate;
  coordinate->SetCoordinateSystemToNormalizedViewport();

  vtkNew<vtkPolyDataMapper2D> mapper;
  mapper->SetInputData(poly);
  mapper->SetTransformCoordinate(coordinate);

  vtkNew<vtkActor2D> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetColor(color);

  // line width should be at least 2 to be visible at extremes
  actor->GetProperty()->SetLineWidth(4.0); // Line Width

  renderer->AddViewProp(actor);
}

} // namespace
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadAllPolyDataTypesDemo)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkCommonSystem
  vtkFiltersSources
  vtkIOGeometry
  vtkIOLegacy
  vtkIOPLY
  vtkIOXML
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadAllPolyDataTypesDemo: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadAllPolyDataTypesDemo MACOSX_BUNDLE ReadAllPolyDataTypesDemo.cxx )
  target_link_libraries(ReadAllPolyDataTypesDemo PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadAllPolyDataTypesDemo MACOSX_BUNDLE ReadAllPolyDataTypesDemo.cxx )
  target_link_libraries(ReadAllPolyDataTypesDemo PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadAllPolyDataTypesDemo
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadAllUnstructuredGridTypes

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadAllUnstructuredGridTypes.png?raw=true)


## 描述

The example reads a vtkUnstructuredGrid with vtkXMLUnstructuredGridReader if the extension is .vtu or the legacy vtkUnstructuredGridReader if the extension is .vtk. If a file is not present, the example creates a vtkUnstructuredGrid by passing a vtkSphere through vtkAppendFilter.

如果扩展名为.vtu，则该示例将使用vtkXMLUnstructuredGridReader读取vtkunstucturedgrid；如果扩展名为.vtk，则该示例将读取旧版vtkunstucturedgridreader。如果文件不存在，则该示例将通过vtkAppendFilter传递vtkSphere来创建vtkunstucturedgrid。
有关VTK文件格式的说明，请参阅VTKFileFormats。


## 代码

ReadAllUnstructuredGridTypes.cxx

```cpp
#include <vtkAppendFilter.h>
#include <vtkSphereSource.h>
#include <vtkUnstructuredGrid.h>
#include <vtkUnstructuredGridReader.h>
#include <vtkXMLUnstructuredGridReader.h>

#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkDataSetMapper.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSmartPointer.h>

#include <algorithm>
#include <array>
#include <string>

namespace {
vtkSmartPointer<vtkUnstructuredGrid>
ReadUnstructuredGrid(std::string const& fileName);
}

int main(int argc, char* argv[])
{
  // Vis Pipeline
  vtkNew<vtkNamedColors> colors;

  vtkNew<vtkRenderer> renderer;

  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->SetSize(640, 480);
  renderWindow->AddRenderer(renderer);

  vtkNew<vtkRenderWindowInteractor> interactor;
  interactor->SetRenderWindow(renderWindow);

  renderer->SetBackground(colors->GetColor3d("Wheat").GetData());
  renderer->UseHiddenLineRemovalOn();

  std::cout << "Loading: " << argv[1] << std::endl;
  auto unstructuredGrid = ReadUnstructuredGrid(std::string(argv[1]));

  // Visualize
  vtkNew<vtkDataSetMapper> mapper;
  mapper->SetInputData(unstructuredGrid);
  mapper->ScalarVisibilityOff();

  vtkNew<vtkProperty> backProp;
  backProp->SetDiffuseColor(colors->GetColor3d("Banana").GetData());
  backProp->SetSpecular(.6);
  backProp->SetSpecularPower(30);

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->SetBackfaceProperty(backProp);
  actor->GetProperty()->SetDiffuseColor(colors->GetColor3d("Tomato").GetData());
  actor->GetProperty()->SetSpecular(.3);
  actor->GetProperty()->SetSpecularPower(30);
  actor->GetProperty()->EdgeVisibilityOn();
  renderer->AddActor(actor);
  renderer->GetActiveCamera()->Azimuth(45);
  renderer->GetActiveCamera()->Elevation(45);
  renderer->ResetCamera();
  renderWindow->SetWindowName("ReadAllUnstructuredGridTypes");
  renderWindow->Render();
  interactor->Start();

  return EXIT_SUCCESS;
}

namespace {
vtkSmartPointer<vtkUnstructuredGrid>
ReadUnstructuredGrid(std::string const& fileName)
{
  vtkSmartPointer<vtkUnstructuredGrid> unstructuredGrid;
  std::string extension = "";
  if (fileName.find_last_of(".") != std::string::npos)
  {
    extension = fileName.substr(fileName.find_last_of("."));
  }

  // Drop the case of the extension
  std::transform(extension.begin(), extension.end(), extension.begin(),
                 ::tolower);

  if (extension == ".vtu")
  {
    vtkNew<vtkXMLUnstructuredGridReader> reader;
    reader->SetFileName(fileName.c_str());
    reader->Update();
    unstructuredGrid = reader->GetOutput();
  }
  else if (extension == ".vtk")
  {
    vtkNew<vtkUnstructuredGridReader> reader;
    reader->SetFileName(fileName.c_str());
    reader->Update();
    unstructuredGrid = reader->GetOutput();
  }
  else
  {
    vtkNew<vtkSphereSource> source;
    source->Update();
    vtkNew<vtkAppendFilter> appendFilter;
    appendFilter->AddInputData(source->GetOutput());
    appendFilter->Update();
    unstructuredGrid = appendFilter->GetOutput();
  }

  return unstructuredGrid;
}

} // namespace
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadAllUnstructuredGridTypes)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkFiltersCore
  vtkFiltersSources
  vtkIOLegacy
  vtkIOXML
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadAllUnstructuredGridTypes: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadAllUnstructuredGridTypes MACOSX_BUNDLE ReadAllUnstructuredGridTypes.cxx )
  target_link_libraries(ReadAllUnstructuredGridTypes PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadAllUnstructuredGridTypes MACOSX_BUNDLE ReadAllUnstructuredGridTypes.cxx )
  target_link_libraries(ReadAllUnstructuredGridTypes PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadAllUnstructuredGridTypes
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadCML

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadCML.png?raw=true)


## 描述

This example uses vtkCMLMoleculeReader to read a Chemistry Markup Language file. CML has been developed by Peter Murray-Rust and Henry Rzepa since 1995. It is the de facto XML for chemistry, accepted by publishers and with more than 1 million lines of Open Source code supporting it.

本例使用vtkCMLMoleculeReader读取化学标记语言文件。CML自1995年由Peter Murray Rust和Henry Rzepa开发，它是一种事实上的化学XML，被出版商所接受，并有超过100万行的开源代码支持它。

## 代码

ReadCML.cxx

```cpp
#include <vtkActor.h>
#include <vtkCMLMoleculeReader.h>
#include <vtkCamera.h>
#include <vtkMolecule.h>
#include <vtkMoleculeMapper.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: " << argv[0] << " Filename(.cml) e.g. porphyrin.cml"
              << std::endl;
    return EXIT_FAILURE;
  }
  std::string fname(argv[1]);
  vtkNew<vtkCMLMoleculeReader> cmlSource;

  cmlSource->SetFileName(fname.c_str());

  vtkNew<vtkMoleculeMapper> molmapper;
  molmapper->SetInputConnection(cmlSource->GetOutputPort());

  molmapper->UseBallAndStickSettings();

  vtkNew<vtkNamedColors> colors;

  vtkNew<vtkActor> actor;
  actor->SetMapper(molmapper);
  actor->GetProperty()->SetDiffuse(0.7);
  actor->GetProperty()->SetSpecular(0.5);
  actor->GetProperty()->SetSpecularPower(20.0);

  vtkNew<vtkRenderer> ren;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(ren);
  renderWindow->SetWindowName("ReadCML");

  vtkNew<vtkRenderWindowInteractor> iren;
  iren->SetRenderWindow(renderWindow);

  ren->AddActor(actor);

  renderWindow->SetSize(640, 480);
  renderWindow->Render();
  ren->GetActiveCamera()->Zoom(2.0);
  ren->SetBackground(colors->GetColor3d("Silver").GetData());

  // Finally render the scene
  renderWindow->SetMultiSamples(0);
  renderWindow->GetInteractor()->Initialize();
  renderWindow->GetInteractor()->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadCML)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkDomainsChemistry
  vtkDomainsChemistryOpenGL2
  vtkIOChemistry
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadCML: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadCML MACOSX_BUNDLE ReadCML.cxx )
  target_link_libraries(ReadCML PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadCML MACOSX_BUNDLE ReadCML.cxx )
  target_link_libraries(ReadCML PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadCML
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadExodusData

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadExodusData.png?raw=true)


## 描述

The example uses vtkExodusIIReader to read an ExodusII file. The nodal variable to read is the second argument. The nodal variable is displayed with a color map.
该示例使用vtkexodusii读取器读取ExodusII文件。要读取的节点变量是第二个参数。节点变量用彩色地图显示。


## 代码

ReadExodusData.cxx

```cpp
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkCompositeDataGeometryFilter.h>
#include <vtkExodusIIReader.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc < 3)
  {
    std::cout << "Usage: " << argv[0]
              << " exodus_file.e nodal_variable e.g mug.e convected";
    return EXIT_FAILURE;
  }

  // Read Exodus Data
  vtkNew<vtkExodusIIReader> reader;
  reader->SetFileName(argv[1]);
  reader->UpdateInformation();
  reader->SetTimeStep(10);
  reader->SetAllArrayStatus(vtkExodusIIReader::NODAL,
                            1); // enables all NODAL variables

  // Create Geometry
  vtkNew<vtkCompositeDataGeometryFilter> geometry;
  geometry->SetInputConnection(0, reader->GetOutputPort(0));

  // Mapper
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(geometry->GetOutputPort());
  mapper->SelectColorArray(argv[2]);
  mapper->SetScalarModeToUsePointFieldData();
  mapper->InterpolateScalarsBeforeMappingOn();

  // Actor
  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);

  // Renderer
  vtkNew<vtkRenderer> renderer;
  renderer->AddViewProp(actor);
  renderer->SetBackground(colors->GetColor3d("DimGray").GetData());

  renderer->GetActiveCamera()->SetPosition(9.0, 9.0, 7.0);
  renderer->GetActiveCamera()->SetFocalPoint(0, 0, 0);
  renderer->GetActiveCamera()->SetViewUp(0.2, -0.7, 0.7);
  renderer->GetActiveCamera()->SetDistance(14.5);

  // Window and Interactor
  vtkNew<vtkRenderWindow> window;
  window->AddRenderer(renderer);
  window->SetSize(600, 600);
  window->SetWindowName("ReadExodusData");

  vtkNew<vtkRenderWindowInteractor> interactor;
  interactor->SetRenderWindow(window);
  interactor->Initialize();

  // Show the result
  window->Render();
  interactor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadExodusData)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkFiltersGeometry
  vtkIOExodus
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadExodusData: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadExodusData MACOSX_BUNDLE ReadExodusData.cxx )
  target_link_libraries(ReadExodusData PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadExodusData MACOSX_BUNDLE ReadExodusData.cxx )
  target_link_libraries(ReadExodusData PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadExodusData
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadOBJ

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadOBJ.png?raw=true)


## 描述


This example demonstrates how to read a Wavefront OBJ file. The result is displayed.
本例演示如何读取波前OBJ文件。将显示结果。

## 代码

ReadOBJ.cxx

```cpp
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkOBJReader.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

#include <string>

int main(int argc, char* argv[])
{
  // Parse command line arguments
  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << "Filename(.obj) e.g trumpet.obj"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string filename = argv[1];
  vtkNew<vtkOBJReader> reader;
  reader->SetFileName(filename.c_str());
  reader->Update();

  // Visualize
  vtkNew<vtkNamedColors> colors;
  vtkColor3d backgroundColor = colors->GetColor3d("SpringGreen");
  vtkColor3d actorColor = colors->GetColor3d("HoneyDew");

  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(reader->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetDiffuseColor(actorColor.GetData());

  vtkNew<vtkRenderer> renderer;
  renderer->AddActor(actor);
  renderer->SetBackground(backgroundColor.GetData());
  renderer->ResetCamera();
  renderer->GetActiveCamera()->Azimuth(30);
  renderer->GetActiveCamera()->Elevation(30);
  renderer->GetActiveCamera()->Dolly(1.5);
  renderer->ResetCameraClippingRange();

  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("ReadOBJ");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderWindow->SetSize(640, 480);
  renderWindow->Render();

  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadOBJ)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkIOGeometry
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadOBJ: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadOBJ MACOSX_BUNDLE ReadOBJ.cxx )
  target_link_libraries(ReadOBJ PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadOBJ MACOSX_BUNDLE ReadOBJ.cxx )
  target_link_libraries(ReadOBJ PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadOBJ
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadPDB

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadPDB.png?raw=true)


## 描述

This example reads Protein Data Bank files. The example expects a file in .pdb format for example src/Testing/Data/lys.pdb.

这个例子读取蛋白质数据库文件。该示例需要一个.pdb格式的文件，例如src/Testing/Data/lys.pdb。

## 代码

ReadPDB.cxx
```cpp
#include <vtkGlyph3D.h>
#include <vtkLODActor.h>
#include <vtkNamedColors.h>
#include <vtkPDBReader.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSmartPointer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>

#include <cmath>

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    std::cerr << "Usage: " << argv[0] << " Filename(.pdb) e.g. caffeine.pdb"
              << std::endl;
    return EXIT_FAILURE;
  }
  vtkNew<vtkNamedColors> colors;

  vtkNew<vtkRenderer> renderer;
  renderer->SetBackground(colors->GetColor3d("SlateGray").GetData());
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetSize(640, 480);
  vtkNew<vtkRenderWindowInteractor> interactor;
  interactor->SetRenderWindow(renderWindow);

  vtkNew<vtkPDBReader> pdb;
  pdb->SetFileName(argv[1]);
  pdb->SetHBScale(1.0);
  pdb->SetBScale(1.0);
  pdb->Update();
  std::cout << "# of atoms is: " << pdb->GetNumberOfAtoms() << std::endl;

  double resolution = std::sqrt(300000.0 / pdb->GetNumberOfAtoms());
  if (resolution > 20)
  {
    resolution = 20;
  }
  if (resolution < 4)
  {
    resolution = 4;
  }
  std::cout << "Resolution is: " << resolution << std::endl;
  vtkNew<vtkSphereSource> sphere;
  sphere->SetCenter(0, 0, 0);
  sphere->SetRadius(1);
  sphere->SetThetaResolution(static_cast<int>(resolution));
  sphere->SetPhiResolution(static_cast<int>(resolution));

  vtkNew<vtkGlyph3D> glyph;
  glyph->SetInputConnection(pdb->GetOutputPort());
  glyph->SetOrient(1);
  glyph->SetColorMode(1);
  // glyph->ScalingOn();
  glyph->SetScaleMode(2);
  glyph->SetScaleFactor(0.25);
  glyph->SetSourceConnection(sphere->GetOutputPort());

  vtkNew<vtkPolyDataMapper> atomMapper;
  atomMapper->SetInputConnection(glyph->GetOutputPort());
  atomMapper->UseLookupTableScalarRangeOff();
  atomMapper->ScalarVisibilityOn();
  atomMapper->SetScalarModeToDefault();

  vtkNew<vtkLODActor> atom;
  atom->SetMapper(atomMapper);
  atom->GetProperty()->SetRepresentationToSurface();
  atom->GetProperty()->SetInterpolationToGouraud();
  atom->GetProperty()->SetAmbient(0.1);
  atom->GetProperty()->SetDiffuse(0.7);
  atom->GetProperty()->SetSpecular(0.5);
  atom->GetProperty()->SetSpecularPower(80);
  atom->GetProperty()->SetSpecularColor(colors->GetColor3d("White").GetData());
  atom->SetNumberOfCloudPoints(30000);

  renderer->AddActor(atom);

  vtkNew<vtkTubeFilter> tube;
  tube->SetInputConnection(pdb->GetOutputPort());
  tube->SetNumberOfSides(static_cast<int>(resolution));
  tube->CappingOff();
  tube->SetRadius(0.2);
  tube->SetVaryRadius(0);
  tube->SetRadiusFactor(10);

  vtkNew<vtkPolyDataMapper> bondMapper;
  bondMapper->SetInputConnection(tube->GetOutputPort());
  bondMapper->UseLookupTableScalarRangeOff();
  bondMapper->ScalarVisibilityOff();
  bondMapper->SetScalarModeToDefault();

  vtkNew<vtkLODActor> bond;
  bond->SetMapper(bondMapper);
  bond->GetProperty()->SetRepresentationToSurface();
  bond->GetProperty()->SetInterpolationToGouraud();
  bond->GetProperty()->SetAmbient(0.1);
  bond->GetProperty()->SetDiffuse(0.7);
  bond->GetProperty()->SetSpecular(0.5);
  bond->GetProperty()->SetSpecularPower(80);
  bond->GetProperty()->SetSpecularColor(colors->GetColor3d("White").GetData());

  renderer->AddActor(bond);

  renderWindow->SetWindowName("ReadPDB");
  renderWindow->Render();
  interactor->Initialize();
  interactor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadPDB)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkFiltersCore
  vtkFiltersSources
  vtkIOChemistry
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingLOD
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadPDB: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadPDB MACOSX_BUNDLE ReadPDB.cxx )
  target_link_libraries(ReadPDB PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadPDB MACOSX_BUNDLE ReadPDB.cxx )
  target_link_libraries(ReadPDB PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadPDB
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadPLOT3D

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadPLOT3D.png?raw=true)


## 描述

## 代码
ReadPLOT3D.cxx
```cpp
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkMultiBlockDataSet.h>
#include <vtkMultiBlockPLOT3DReader.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkStructuredGridGeometryFilter.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc < 3)
  {
    std::cout << "Required parameters: XYZFilename.bin QFileName.bin e.g "
                 "combxyz.bin combq.bin"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string xyzFilename(argv[1]);
  std::string qFilename(argv[2]);

  vtkNew<vtkMultiBlockPLOT3DReader> reader;
  reader->SetXYZFileName(xyzFilename.c_str());
  reader->SetQFileName(qFilename.c_str());
  reader->SetScalarFunctionNumber(100);
  reader->SetVectorFunctionNumber(202);
  reader->Update();

  vtkNew<vtkStructuredGridGeometryFilter> geometryFilter;
  geometryFilter->SetInputData(reader->GetOutput()->GetBlock(0));
  geometryFilter->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(geometryFilter->GetOutputPort());
  mapper->ScalarVisibilityOff();

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetColor(colors->GetColor3d("MistyRose").GetData());

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("DarkSlateGray").GetData());

  renderer->ResetCamera();
  renderer->GetActiveCamera()->SetClippingRange(3.95297, 50);
  renderer->GetActiveCamera()->SetFocalPoint(8.88908, 0.595038, 29.3342);
  renderer->GetActiveCamera()->SetPosition(-12.3332, 31.7479, 41.2387);
  renderer->GetActiveCamera()->SetViewUp(0.060772, -0.319905, 0.945498);

  renderWindow->SetWindowName("ReadPLOT3D");
  renderWindow->SetSize(640, 480);
  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadPLOT3D)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkFiltersGeometry
  vtkIOParallel
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadPLOT3D: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadPLOT3D MACOSX_BUNDLE ReadPLOT3D.cxx )
  target_link_libraries(ReadPLOT3D PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadPLOT3D MACOSX_BUNDLE ReadPLOT3D.cxx )
  target_link_libraries(ReadPLOT3D PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadPLOT3D
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadPLY

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadPLY.png?raw=true)


## 描述

## 代码

ReadPLY.cxx
```cpp
#include <vtkActor.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPLYReader.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << "  Filename(.ply) e.g. shark.ply"
              << std::endl;
    return EXIT_FAILURE;
  }

  std::string inputFilename = argv[1];

  vtkNew<vtkPLYReader> reader;
  reader->SetFileName(inputFilename.c_str());

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(reader->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetColor(colors->GetColor3d("DarkGray").GetData());

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("SeaGreen").GetData());

  renderWindow->SetWindowName("ReadPLY");
  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadPLY)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkIOPLY
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadPLY: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadPLY MACOSX_BUNDLE ReadPLY.cxx )
  target_link_libraries(ReadPLY PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadPLY MACOSX_BUNDLE ReadPLY.cxx )
  target_link_libraries(ReadPLY PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadPLY
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```


# VTK：IO-标准格式之 ReadPlainTextTriangles

![]()


## 描述

Here is an example of a custom file-format reader that produces a VTK XML PolyData file from a plain-text input format.
下面是一个自定义文件格式读取器的示例，该读取器从纯文本输入格式生成vtkxml PolyData文件。

Input Format

```
number_of_points
number_of_triangles
point[point[0]Y point[0](0]X)Z
point[point[1]Y point[1](1]X)Z
...
point[point[N]Y point[N](N]X)Z
triangle[triangle[0]B triangle[0](0]A)C
triangle[triangle[1]B triangle[1](1]A)C
...
triangle[triangle[M]B triangle[M](M]A)C
```

Example Input

```
3
1
0.0 0.0 0.0
0.0 0.0 1.0
0.0 1.0 0.0
0 1 2
```

## 代码

ReadPlainTextTriangles.cxx

```cpp
#include <vtkCellArray.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkSmartPointer.h>
#include <vtkXMLPolyDataWriter.h>

#include <iostream>

namespace {
vtkSmartPointer<vtkPolyData> custom_reader(std::ifstream& infile);
}

int main(int argc, char* argv[])
{
  // Verify command line arguments
  if (argc != 2)
  {
    std::cerr << "Required arguments: triangleFile.txt" << std::endl;
    return EXIT_FAILURE;
  }

  std::string inputFilename = argv[1];

  std::ifstream fin(inputFilename.c_str());

  auto polydata = custom_reader(fin);

  vtkNew<vtkXMLPolyDataWriter> writer;
  writer->SetInputData(polydata);
  writer->SetFileName("x.vtp");
  writer->Write();
  return EXIT_SUCCESS;
}

namespace {
vtkSmartPointer<vtkPolyData> custom_reader(std::ifstream& infile)
{
  vtkIdType number_of_points, number_of_triangles;
  infile >> number_of_points >> number_of_triangles;

  vtkNew<vtkPoints> points;
  points->SetNumberOfPoints(number_of_points);
  for (vtkIdType i = 0; i < number_of_points; i++)
  {
    double x, y, z;
    infile >> x >> y >> z;
    points->SetPoint(i, x, y, z);
  }

  vtkNew<vtkCellArray> polys;
  for (vtkIdType i = 0; i < number_of_triangles; i++)
  {
    vtkIdType a, b, c;
    infile >> a >> b >> c;
    polys->InsertNextCell(3);
    polys->InsertCellPoint(a);
    polys->InsertCellPoint(b);
    polys->InsertCellPoint(c);
  }
  auto polydata = vtkSmartPointer<vtkPolyData>::New();
  polydata->SetPoints(points);
  polydata->SetPolys(polys);
  return polydata;
}
} // namespace
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadPlainTextTriangles)

find_package(VTK COMPONENTS 
  vtkCommonCore
  vtkCommonDataModel
  vtkIOXML
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadPlainTextTriangles: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadPlainTextTriangles MACOSX_BUNDLE ReadPlainTextTriangles.cxx )
  target_link_libraries(ReadPlainTextTriangles PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadPlainTextTriangles MACOSX_BUNDLE ReadPlainTextTriangles.cxx )
  target_link_libraries(ReadPlainTextTriangles PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadPlainTextTriangles
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```
# VTK：IO-标准格式之 ReadSLC

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadSLC.png?raw=true)


## 描述

In this example you will familiarize yourself with the stages required to read a .slc file and create a visualization pipeline in VTK. Following is the three step procedure:
在本例中，您将熟悉在VTK中读取.slc文件和创建可视化管道所需的阶段。以下是三步程序：

Read the data from .slc file using vtkSLCReader
Implement Marching cubes Algorithm using vtkContourFilter
Create Visualization pipeline to visualize data using an actor, mapper and rendering window

使用vtkSLCReader从.slc文件读取数据
用vtkContourFilter实现Marching立方体算法
创建可视化管道以使用actor、mapper和渲染窗口可视化数据



## 代码

ReadSLC.cxx
```cpp
#include <vtkActor.h>
#include <vtkCamera.h>
#include <vtkContourFilter.h>
#include <vtkExtractVOI.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkOutlineFilter.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSLCReader.h>

// Author: Bharatesh Chakravarthi
// Affiliation: Virtual Environment Lab, Chung-Ang University, Seoul, South
// Korea

int main(int argc, char* argv[])
{
  if (argc < 2)
  {
    // Pass the filename (<filename>.slc) as parameter to read .slc file
    std::cout << "Required parameters: Filename(.slc) e.g vw_knee.slc"
              << std::endl;
    return EXIT_FAILURE;
  }

  double isoValue = 72.0;
  if (argc < 3)
  {
    isoValue = 72.0;
  }
  else
  {
    isoValue = std::atof(argv[2]);
  }
  std::string inputFilename = argv[1];

  // Using vtkSLCReader to read Volumetric file format(<filename.slc>)
  vtkNew<vtkSLCReader> reader;
  reader->SetFileName(inputFilename.c_str());
  reader->Update();

  // Implementing Marching Cubes Algorithm to create the surface using
  // vtkContourFilter object
  vtkNew<vtkContourFilter> cFilter;
  cFilter->SetInputConnection(reader->GetOutputPort());

  // Change the range(2nd and 3rd Paramater) based on your
  // requirement. recomended value for 1st parameter is above 1
  // cFilter->GenerateValues(5, 80.0, 100.0);
  cFilter->SetValue(0, isoValue);
  cFilter->Update();

  // Adding the outliner using vtkOutlineFilter object
  vtkNew<vtkOutlineFilter> outliner;
  outliner->SetInputConnection(reader->GetOutputPort());
  outliner->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(cFilter->GetOutputPort());
  mapper->SetScalarVisibility(0);

  vtkNew<vtkNamedColors> colors;

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetDiffuse(0.8);
  actor->GetProperty()->SetDiffuseColor(colors->GetColor3d("Ivory").GetData());
  actor->GetProperty()->SetSpecular(0.8);
  actor->GetProperty()->SetSpecularPower(120.0);

  // extractVOI is used to fix the problem of subsampling of data and reduce
  // slow interaction and increase loading speed
  vtkNew<vtkExtractVOI> extractVOI;
  extractVOI->SetInputConnection(reader->GetOutputPort());
  extractVOI->SetSampleRate(2, 2, 2);
  extractVOI->Update();

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetSize(640, 512);

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("SlateGray").GetData());
  renderWindow->Render();

  // Pick a good view
  vtkCamera* cam1 = renderer->GetActiveCamera();
  cam1->SetFocalPoint(0.0, 0.0, 0.0);
  cam1->SetPosition(0.0, -1.0, 0.0);
  cam1->SetViewUp(0.0, 0.0, -1.0);
  cam1->Azimuth(-90.0);
  renderer->ResetCamera();
  renderer->ResetCameraClippingRange();

  renderWindow->SetWindowName("ReadSLC");
  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadSLC)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkFiltersCore
  vtkFiltersModeling
  vtkIOImage
  vtkImagingCore
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadSLC: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadSLC MACOSX_BUNDLE ReadSLC.cxx )
  target_link_libraries(ReadSLC PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadSLC MACOSX_BUNDLE ReadSLC.cxx )
  target_link_libraries(ReadSLC PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadSLC
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadSTL

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadSTL.png?raw=true)


## 描述

## 代码

ReadSTL.cxx

```cpp
#include <vtkActor.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyData.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSTLReader.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  if (argc != 2)
  {
    cout << "Required parameters: Filename(.stl) e.g 42400-IDGH.stl" << endl;
    return EXIT_FAILURE;
  }

  std::string inputFilename = argv[1];

  vtkNew<vtkSTLReader> reader;
  reader->SetFileName(inputFilename.c_str());
  reader->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(reader->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetDiffuse(0.8);
  actor->GetProperty()->SetDiffuseColor(
      colors->GetColor3d("LightSteelBlue").GetData());
  actor->GetProperty()->SetSpecular(0.3);
  actor->GetProperty()->SetSpecularPower(60.0);

  vtkNew<vtkRenderer> renderer;
  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("ReadSTL");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("DarkOliveGreen").GetData());

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadSTL)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkCommonDataModel
  vtkIOGeometry
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadSTL: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadSTL MACOSX_BUNDLE ReadSTL.cxx )
  target_link_libraries(ReadSTL PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadSTL MACOSX_BUNDLE ReadSTL.cxx )
  target_link_libraries(ReadSTL PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadSTL
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 ReadTextFile

![](https://github.com/Kitware/vtk-examples/blob/gh-pages/src/Testing/Baseline/Cxx/IO/TestReadTextFile.png?raw=true)


## 描述

This example takes a plain text file of coordinates and reads them into a vtkPoints, which is then put into a vtkPolyData and displayed on the screen using a vtkVertexGlyphFilter.

An example file may look like: 1 2 3 4 5 6 7 8 9

此示例获取坐标的纯文本文件并将其读入vtkPoints，然后将其放入vtkPolyData并使用vtkVertexGlyphFilter显示在屏幕上。

示例文件可能如下所示：1 2 3 4 5 6 7 8 9

## 代码

ReadTextFile.cxx
```cpp
#include <vtkActor.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPoints.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkVertexGlyphFilter.h>

#include <sstream>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  // Verify input arguments
  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << " Filename(.txt) e.g. TeapotPoints.txt"
              << std::endl;
    return EXIT_FAILURE;
  }
  // Get all data from the file
  std::string filename = argv[1];
  std::ifstream filestream(filename.c_str());

  std::string line;
  vtkNew<vtkPoints> points;

  while (std::getline(filestream, line))
  {
    double x, y, z;
    std::stringstream linestream;
    linestream << line;
    linestream >> x >> y >> z;

    points->InsertNextPoint(x, y, z);
  }

  filestream.close();

  vtkNew<vtkPolyData> polyData;

  polyData->SetPoints(points);

  vtkNew<vtkVertexGlyphFilter> glyphFilter;
  glyphFilter->SetInputData(polyData);
  glyphFilter->Update();

  // Visualize

  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(glyphFilter->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetColor(colors->GetColor3d("MidnightBlue").GetData());

  vtkNew<vtkRenderer> renderer;
  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("Gainsboro").GetData());

  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("ReadTextFile");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(ReadTextFile)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkFiltersGeneral
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping ReadTextFile: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(ReadTextFile MACOSX_BUNDLE ReadTextFile.cxx )
  target_link_libraries(ReadTextFile PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(ReadTextFile MACOSX_BUNDLE ReadTextFile.cxx )
  target_link_libraries(ReadTextFile PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS ReadTextFile
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```

# VTK：IO-标准格式之 SimplePointsReader

![]()


## 描述

## 代码
```cpp

```
CMakeLists.txt
```cpp

```





# VTK：

## 描述

A file of XYZ coordinates is a very easy format that can be used for simple storage from many applications. This example demonstrates how to read this type of file into a polydata object. An example file of three points would look like this:
XYZ坐标文件是一种非常简单的格式，可用于许多应用程序的简单存储。此示例演示如何将此类型的文件读入polydata对象。包含三个点的示例文件如下所示：
```
 0.0 0.0 0.0
 1.0 0.0 0.0
 0.0 1.0 0.0
```
As a demo, save the above three lines to a file called simple.xyz and call the executable resulting from the code below with
作为演示，将以上三行保存到一个名为simple.xyz的文件中，并使用

> ./SimplePointsReader simple.xyz

## 代码

SimplePointsReader.cxx

```cpp
#include <vtkActor.h>
#include <vtkNamedColors.h>
#include <vtkNew.h>
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkSimplePointsReader.h>

int main(int argc, char* argv[])
{
  vtkNew<vtkNamedColors> colors;

  // Verify input arguments
  if (argc != 2)
  {
    std::cout << "Usage: " << argv[0] << " Filename(.xyz) e.g coords.txt"
              << std::endl;
    return EXIT_FAILURE;
  }

  // Read the file
  vtkNew<vtkSimplePointsReader> reader;
  reader->SetFileName(argv[1]);
  reader->Update();

  // Visualize
  vtkNew<vtkPolyDataMapper> mapper;
  mapper->SetInputConnection(reader->GetOutputPort());

  vtkNew<vtkActor> actor;
  actor->SetMapper(mapper);
  actor->GetProperty()->SetPointSize(6);
  actor->GetProperty()->SetColor(colors->GetColor3d("Gold").GetData());

  vtkNew<vtkRenderer> renderer;
  renderer->AddActor(actor);
  renderer->SetBackground(colors->GetColor3d("DarkGreen").GetData());

  vtkNew<vtkRenderWindow> renderWindow;
  renderWindow->AddRenderer(renderer);
  renderWindow->SetWindowName("SimplePointsReader");

  vtkNew<vtkRenderWindowInteractor> renderWindowInteractor;
  renderWindowInteractor->SetRenderWindow(renderWindow);

  renderWindow->Render();
  renderWindowInteractor->Start();

  return EXIT_SUCCESS;
}
```
CMakeLists.txt
```cpp
cmake_minimum_required(VERSION 3.3 FATAL_ERROR)

project(SimplePointsReader)

find_package(VTK COMPONENTS 
  vtkCommonColor
  vtkCommonCore
  vtkIOLegacy
  vtkInteractionStyle
  vtkRenderingContextOpenGL2
  vtkRenderingCore
  vtkRenderingFreeType
  vtkRenderingGL2PSOpenGL2
  vtkRenderingOpenGL2
  QUIET
)

if (NOT VTK_FOUND)
  message("Skipping SimplePointsReader: ${VTK_NOT_FOUND_MESSAGE}")
  return ()
endif()
message (STATUS "VTK_VERSION: ${VTK_VERSION}")
if (VTK_VERSION VERSION_LESS "8.90.0")
  # old system
  include(${VTK_USE_FILE})
  add_executable(SimplePointsReader MACOSX_BUNDLE SimplePointsReader.cxx )
  target_link_libraries(SimplePointsReader PRIVATE ${VTK_LIBRARIES})
else ()
  # include all components
  add_executable(SimplePointsReader MACOSX_BUNDLE SimplePointsReader.cxx )
  target_link_libraries(SimplePointsReader PRIVATE ${VTK_LIBRARIES})
  # vtk_module_autoinit is needed
  vtk_module_autoinit(
    TARGETS SimplePointsReader
    MODULES ${VTK_LIBRARIES}
    )
endif ()
```